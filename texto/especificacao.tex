\chapter{Especificação}\label{chp:Especificação}
O projeto foi desenvolvido para dispositivos móveis utilizando \textit{tecnologia de desenvolvimento híbrida}, visando facilitar o desenvolvimento e o \textit{deploy} em diversas plataformas móveis. Neste capítulo descreveremos a especificação técnica do \textit{backend} e do aplicativo mobile do projeto.

\section{Tecnologias do \textit{Backend}}\label{sec:spec-backend}
Como solução de \textit{backend} foi utilizado o \textit{framework} \gls{django}, que utiliza a linguagem de programação \textbf{Python} e é organizado segundo a \textit{design pattern} \gls{mvt}, conforme pode ser visto nas Figuras \ref{fig:arqMVT} e \ref{fig:arqDjango}.%
%
\diagramaRetrato{arquitetura-app-django.png}{0.8}{Arquitetura MVT de um APP do framework Django}{arqMVT}{Jeff Croft em {\footnotesize\url{http://www.flickr.com/photos/jcroft/432038560/sizes/o/in/photostream/}}}{}%
%
\diagramaRetrato{django-arq2.eps}{1.1}{Arquitetura do framework Django}{arqDjango}{Autoria própria}{baseado em {\footnotesize\url{http://www.slideshare.net/AbhijeetShekhar1/django-39439148}}}

A estrutura de projeto do \textit{framework} é pensada de forma modular, na qual a aplicação é composta por ''\textit{apps}'' independentes que realizam funções específicas e são conectados no projeto, conforme pode ser visto na Figura \ref{fig:multiApps}.%
%
\diagramaRetrato{django-multi-apps.jpg}{0.45}{Arquitetura multi-aplicativos do Django}{multiApps}{Ian Ward em {\footnotesize\url{http://excess.org/article/2007/06/oclug-django-site/}}}{}

Considerando tal arquitetura, foram desenvolvidos os 3 módulos principais já descritos anteriormente, na Seção \ref{sec:Escopo} (\textbf{Avaliação}, \textbf{Game} e \textbf{GPS social}). Além destes, também foi necessária a criação de um módulo adicional (\textit{utils}) com a finalidade de suprir algumas integrações entre os \textit{apps} sem impactar no isolamento entre eles. A função principal deste módulo foi a de criar a \gls{api} \gls{rest} do projeto

A \gls{api} \gls{rest} foi implementada utilizando-se o pacote \gls{drf}\footnote{\url{http://www.django-rest-framework.org}}. Com o uso do \gls{drf} foi necessário desenvolver algumas classes serializadoras vinculadas aos modelos de dados que seriam expostos (\textit{models}), em seguida criar as respectivas \textit{views} e criar um \textit{Router} com as urls que seriam expostas. Sequer foi necessária a criação de templates, visto que o pacote já fornece um template padrão. O módulo expõe os dados no formato \gls{json}, para além da apresentação na interface web, sem que seja necessário qualquer desenvolvimento ou configuração.

Foi utilizado também o pacote \gls{psa} para permitir a autenticação dos usuários com seus logins de redes sociais. Neste primeiro momento foram disponibilizados os logins via \textit{Facebook}\footnote{\url{https://developers.facebook.com/docs/facebook-login/v2.2}} e via \textit{Google Social Login}\footnote{\url{https://developers.google.com/+/web/signin/}}, ambos utilizando o protocolo de autenticação OAuth 2.0\footnote{\url{http://oauth.net/2/}}. Neste primeiro momento não foi utilizada a rede social \textit{Twitter} pois a mesma não disponibiliza o e-mail do usuário ao realizar o login, o que impede que possamos vincular a conta da rede social com usuários já cadastrados.

Como o aplicativo lida com dados georreferenciados, para \gls{sgbd} foi escolhido o \textbf{PostgreSQL} com a extensão \textbf{PostGis}, visto que esta é a solução mais amplamente utilizada no mercado e com melhor suporte, além de ser a recomendada pelos desenvolvedores do \gls{django}, de sua extensão ``geo'' e da biblioteca python (\textit{gdal (Geospatial Data Abstraction Library)}). A solução escolhida permite inclusive realizar consultas utilizando critérios de geolocalização como, por exemplo, ``Selecionar todos os registros cuja localização se encontra num raio de X metros do ponto Y'', o que é fundamental para a criação do módulo \textbf{mapa}.

O framework \gls{django} por si só não é um servidor web - ele apenas possui um micro-servidor para fins de teste e desenvolvimento; então faz-se necessário utilizar um servidor web. No presente projeto optou-se pelo \gls{nginx}, o servidor web que tem crescido no ritmo mais acelerado dos que possuem pelo menos 1\% do mercado. Seu ritmo anual médio de crescimento de 2010 a 2014 43\%, e hoje ele já ocupa a segunda colocação como servidor mais utilizado na internet com 22,6\% do mercado, atrás apenas do Apache, que tem 59\% do mercado mas que tem perdido, em média, 3,71\% de \textit{market share} ao ano, conforme pode ser observado na Figura \ref{fig:nginxmarkershare}.

\diagramaRetrato{market_share_webservers.png}{0.55}{\textit{Market Share} de servidores web}{nginxmarkershare}{W3Techs - Web Technology Surveys {\footnotesize\url{http://w3techs.com/technologies/history_overview/web_server/ms/y}}}{}

Além dessa grande exposição, e de possuir uma boa documentação\footnote{\url{http://nginx.org/en/docs/}}, outra vantagem é que ele consegue cumprir a função de servidor web, proxy reverso e também possui recursos de \textit{load balance}, tornado-o uma ótima alternativa em termos de escalabilidade.

O \gls{nginx} por si só não consegue "fornecer" diretamente a aplicação django, para tanto é preciso ainda mais um elemento, que é o servidor de aplicações. Para tanto, um dos que apresenta melhor desempenho nos dias de hoje para servir projetos que utilizam a linguagem de programação Python é o \gls{uwsgi}\footnote{\url{https://ivan-site.com/2012/09/benchmark-uwsgi-vs-gunicorn-for-async-workers/}}$^,$\footnote{\url{http://blog.kgriffs.com/2012/12/18/uwsgi-vs-gunicorn-vs-node-benchmarks.html}}$^,$\footnote{\url{http://www.peterbe.com/plog/fcgi-vs-gunicorn-vs-uwsgi}}. Dessa maneira, optamos pelo \gls{uwsgi} como servidor de aplicação trabalhando em conjunto com o \gls{nginx} como servidor web.

Fica como sugestão para o futuro do projeto a utilização do servidor de cache \textit{varnish}\footnote{\url{https://www.varnish-cache.org/}}, conforme recomendado pela equipe do hosting DigitalOcean\footnote{\url{https://www.digitalocean.com/community/tutorials/how-to-scale-django-beyond-the-basics}}, para conseguir escalar o projeto sem precisar necessariamente de mais recursos de máquina.

\section{Modelagem de Dados}\label{sec:diagrama-er}
Na figura \ref{fig:DiagER} encontra-se a modelagem de dados realizada inicialmente no projeto. Esta modelagem não leva em consideração as especificidades do \textit{framework} utilizado, e eventuais diferenças serão expostas na descrição dos \textit{apps}.
\diagramaRetrato{diagramas_er_bds.eps}{1.2}{Diagrama Entidade Relacionamento}{DiagER}{Autoria Própria}{}

\section{Implementação}\label{sec:estrutura-app}
Nesta seção iremos descrever a rotina de implementação da infraestrutura de backend como um todo e a implementação de cada um dos \textit{apps}, assim como do projeto \gls{django} que integra os \textit{apps}. Cada \textit{app} será descrito considerando o \textit{design pattern} \gls{mvt}.

A implementação completa dos \textit{models}, das \textit{views}, \textit{serializers} e \textit{urls} pode ser encontrada no Anexo \ref{anexo:sources} ou no repositório oficial do projeto\footnote{Repositório Oficial do Projeto: \url{http://github.com/diraol/trilhasp}}

\subsection{Setup Inicial}
Para o \textit{setup} inicial do servidor foi criado um \textit{shell script} que realiza toda a instalação. Ele foi desenvolvido e testado para o sistema operacional \textbf{Debian Jessie (8.0)}.

Este setup inicial contempla a instalação do \gls{django}, do \gls{sgbd} \textbf{PostgreSQL} (v9.4), com sua extensão de dados espaciais \textbf{PostGis} (v2.1), além dos pacotes necessários para a utilização do recurso de ambientes virtuais (\textit{Virtualenv}) do \textbf{Python}, o que facilita o encapsulamento e a manutenabilidade da aplicação num servidor.

Requisitos para a utilização de ambientes virtuais: %
\begin{enumerate*}[label=\itshape\alph*\upshape)] 
    \item \mbox{\textit{python-setuptools}};
    \item \mbox{\textit{python-pip}};
    \item \mbox{\textit{python-dev}}
\end{enumerate*}.

Requisitos para a base de dados espaciais e sua integração com o Python: %
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item\mbox{\textit{postgresql-9.4}};
    \item\mbox{\textit{postgresql-contrib-9.4}};
    \item\mbox{\textit{postgresql-9.4-postgis}};
    \item\mbox{\textit{postgresql-server-dev-9.4}};
    \item\mbox{\textit{libpq-dev}};
    \item\mbox{\textit{binutils}};
    \item\mbox{\textit{libproj-dev}};
    \item\mbox{\textit{gdal-bin}};
    \item\mbox{\textit{python-gdal}};
    \item\mbox{\textit{python-psycopg2}}
\end{enumerate*}.

Após instalados os pacotes, o script irá realizar a criação de um usuário \textit{trilhasp} no PostgreSQL, será requisitado ao usuário para inserir um \textit{password}, será criada a base de dados dentro do \gls{sgbd}, com codificação (\textit{encoding}) UTF-8, serão instaladas as extensões de georreferenciamento nesta base.

Em seguida é instalado o pacote \textit{virtualenv} do \textbf{Python}, com o uso da ferramenta de gerenciamento de pacotes \textit{pip}, é criado um novo ambiente virtual (numa pasta chamada \textbf{venv}), que é ativado e no qual são instalados os demais \textit{requirements} de python, que ficam definidos no arquivo \textit{requirements.txt}.

Finalizando o setup inicial do \gls{django}, o script irá executar os comandos para criação das bases de dados, tomando como referência os modelos (\textit{models}) de todas as aplicações listadas nas configurações do django.

\subsection{Configuração do Django}
A configuração do django se dá basicamente no arquivo \textit{settings.py} do projeto....
%TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP AVALIAÇÃO                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Avaliação}
Começaremos pelo  \textit{app} responsável pela avaliação do sistema de transporte.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:eval-camada-model}
Foram definidos os seguintes modelos, que representam classes, e que possuem os respectivos atributos:
\begin{description}
    \item[BusCompanies] - Empresa de ônibus
        \begin{itemize}
            \item \textbf{company\_name} Tipo: CharField - Nome da empresa
            \item \textbf{logo} Tipo: ImageField - Logo da empresa
        \end{itemize}
    \item[BusLine] - Linha de ônibus
        \begin{itemize}
            \item \textbf{bus\_line\_code} Tipo: CharField - Código da linha de ônibus
            \item \textbf{going\_bus\_name} Tipo: CharField - Nome do trajeto de ida
            \item \textbf{return\_bus\_name} Tipo: CharField - Nome do trajeto de volta
            \item \textbf{active} Tipo: BooleanField - Estado da linha (ativa ou desativa)
            \item \textbf{company\_name} Tipo: ForeignKey - Empresa responsável pela linha
        \end{itemize}
        Chave primária composta: \textit{bus\_line\_code} e \textit{active}
    \item[Buses] - Ônibus único
        \begin{itemize}
            \item \textbf{bus\_unique\_number} Tipo: IntegerField - Número único de cada ``carro'' (ônibus), pintado na lateral do mesmo.
            \item \textbf{bus\_line\_code} Tipo: ForeignKey - Código da linha que este ônibus percorre
            \item \textbf{active} Tipo: BooleanField - Estado da linha (ativa ou desativa)
        \end{itemize}
        Chave primária composta: \textit{bus\_unique\_number} e \textit{active}
    \item[EVALAnswerModel] - Modelos de respostas
        \begin{itemize}
            \item \textbf{answer} Tipo: CharField - Texto explicativo deste tipo de resposta
            \item \textbf{lower\_limit\_text} Tipo: CharField - Label do valor superior
            \item \textbf{upper\_limit\_text} Tipo: CharField - Label do valor inferior
            \item \textbf{middle\_text} Tipo: CharField - Label do valor central
            \item \textbf{lower\_limit\_value} Tipo: IntegerField - Valor do limite inferior
            \item \textbf{upper\_limit\_value} Tipo: IntegerField - Valor do limite superior
            \item \textbf{middle\_value} Tipo: IntegerField - Valor central
        \end{itemize}
    \item[EVALQuestion] - Perguntas
        \begin{itemize}
            \item \textbf{question} Tipo: CharField - Texto da questão, que será mostrado ao usuário
            \item \textbf{answer} Tipo: ForeignKey - Tipo da resposta para esta pergunta
            \item \textbf{enabled} Tipo: Estado da pergunta (ativa ou desativa)
        \end{itemize}
    \item[EVALAnswer] - Respostas dos usuários
        \begin{itemize}
            \item \textbf{question} Tipo: ForeignKey - Questão
            \item \textbf{user} Tipo: ForeignKey - Usuário respondente
            \item \textbf{timestamp} Tipo: DateTimeField - Data e Horário da resposta
            \item \textbf{answer\_value} Tipo: IntegerField - Valor numérico da resposta
            \item \textbf{answer\_text} Tipo: CharField - Texto inserido pelo usuário (em caso de resposta abaixo do valor central)
            \item \textbf{bus\_unique\_number} Tipo: ForeignKey - Número único do ônibus
            \item \textbf{geolocation} Tipo: PointField - Geolocalização do usuário no momento da resposta
        \end{itemize}
\end{description}

\subsubsection{Serializadores}
Para a criação da \gls{api} o \gls{drf} requer que o desenvolvedor crie um (ou mais) serializador(es) para cada classe que deseja expor e, em seguida, crie as views que utilizam esses serializadores no lugar dos ``\textit{models}''.

Assim, para este \textit{app} foram criados os seguintes serializadores: %
\begin{itemize}
    \item \textit{BusCompaniesSerializer};
    \item \textit{BusLineSerializer};
    \item \textit{BusesSerializer};
    \item \textit{EVALAnswerModelSerializer};
    \item \textit{EVALQuestionSerializer};
    \item \textit{EVALAnswerSerializer}
\end{itemize}
Todos eles foram criados como extensões da classe \textit{serializers.HyperlinkedModelSerializer}, o que faz com que a \gls{api} exposta faça o link entre objetos que são chave-estrangeira e o objeto que está sendo mostrado.

\subsubsection{Camada de lógica de negócio (\textit{views})}\label{subsubsec:eval-camada-view}
Esta camada irá expor os serializadores definidos anteriormente. As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{BusCompanyViewSet};
    \item \textit{BusLineViewSet};
    \item \textit{BusesViewSet};
    \item \textit{EVALAnswerModelViewSet};
    \item \textit{EVALQuestionViewSet};
    \item \textit{EVALAnswerViewSet}
\end{itemize}
Estas classes foram definidas como extensões da classe ViewSet do \gls{drf}, o que já contempla automaticamente a criação de \textit{views} para lista de resultados e também para um resultado único em cada visão. Além disso, é na definição destas classes que podemos especificar as permissões de acesso, caso desejamos uma diferente da default configurada.

\subsubsection{Camada de Template e URLs}
Como não foi criada nenhuma ``página'' publicamente acessível, não foi necessária a criação de template - o \gls{drf} utiliza um template default para a \gls{api} no browser. Quanto às URLs, elas serão definidas no arquivo de URLs do projeto \gls{django}.

\subsubsection{Camada de Adminsitração}
O \gls{django} oferece por padrão um módulo de administração da aplicação, bastando ativá-lo no arquivo de configurações. Em seguida, para cada \textit{app} é necessário registrar quais são as classes (do modelo) que estarão disponíveis para administração, e, eventualmente, fazer alguma personalização na forma como a mesma é exposta.

No caso deste \textit{app} todas as classes foram expostas e ainda adicionou-se uma configuração para que a informação georreferenciada fosse apresentada num widget de mapa, ao invés de se apresentar uma coordenada apenas. Esta configuração encontra-se no arquivo \textit{admin.py} do \textit{app} e também está disponível no Anexo \ref{anexo:sources}.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP GPSSocial                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP GPSSocial}
Agora veremos o \textit{app} responsável pelo mapa de GPS Social.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:gps-camada-model}
Foram definidos os seguintes modelos, que representam classes, e que possuem os respectivos atributos:
\begin{description}
    \item[GEOLastPosition] - Tabela com a última posição de cada usuário
        \begin{itemize}
            \item \textbf{user} Tipo: ForeignKey - Usuário;
            \item \textbf{geolocation} Tipo: PointField - Localização do usuário;
            \item \textbf{timestamp} Tipo: DateTimeField - Horário do registro da localização.
        \end{itemize}
    \item[GEOHistoryPosition] - Histórico de localização de todos os usuários
        \begin{itemize}
            \item \textbf{user} Tipo: ForeignKey - Usuário;
            \item \textbf{geolocation} Tipo: PointField - Localização do usuário;
            \item \textbf{timestamp} Tipo: DateTimeField - Horário do registro da localização.
        \end{itemize}
\end{description}
Optou-se por criar uma tabela com a última localização dos usuários para melhorar o desempenho nas consultas para o GPS social, reduzindo o número de registros a serem consultados para esta funcionalidade.

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores: %
\begin{itemize}
    \item \textit{GEOLastPositionSerializer};
    \item \textit{GEOLastAnonPositionSerializer};
    \item \textit{GEOHistoryPositionSerializer}.
\end{itemize}
Os serializadores \textit{GEOLastPositionSerializer} e \textit{GEOLastAnonPositionSerializer} são extensões da classe \mbox{\textit{GeoFeatureModelSerializer}} (do módulo \gls{drf}-geo), e o serializador \mbox{\textit{GEOHistoryPositionSerializer}} é uma extensão da classe \mbox{\textit{HyperlinkedModelSerializer}}.

Aqui nota-se que há mais serializadores que classes no modelo. Isto ocorreu pois foi criado um serializador para oferecer as informações dos usuários de forma anonimizada, garantindo a privacidade dos usuários.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Esta camada irá expor os serializadores definidos anteriormente. As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{GEOLastPositionViewSet};
    \item \textit{LastUserPosition};
    \item \textit{LastUsersAtPosition};
    \item \textit{GEOHistoryPositionViewSet}
\end{itemize}
Aqui percebemos quatro classes. Duas classes padrões (\mbox{\textit{GEOLastPositionViewSet}} e \mbox{\textit{GEOHistoryPositionViewSet}}), que basicamente expõe os dados dos respectivos modelos, e duas classes mais específicas. Em ambos os casos, se o usuário não é administrador ele não tem como saber a qual usuário cada registro está vinculado (a informação é anonimizada).

A classe \textit{LastUserPosition}, que estará vinculada a uma URL que permitirá obter a última posição de um determinado usuário, por seu username. 

E a classe \textit{LastUsersAtPosition}, que retorna os registros (anonimizados) que estão a uma distância pré-determinada de um determinado ponto (latitude e longitue) e que tenha sido atualizado há menos de uma hora.

\subsubsection{Camada de Template e URLs}
Como não foi criada nenhuma ``página'' publicamente acessível, não foi necessária a criação de template - o \gls{drf} utiliza um template default para a \gls{api} no browser. Quanto às URLs, elas serão definidas no arquivo de URLs do projeto \gls{django}.

\subsubsection{Camada de Adminsitração}
Neste \textit{app} foram expostas as duas classes do ``modelo'', sem nenhuma configuração adicional.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                 APP Game                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Game}
Agora veremos o \textit{app} responsável pelo game.
\subsubsection{Camada de Acesso a Dados (\textit{model})}
Foram definidos os seguintes modelos, que representam classes, e seus respectivos atributos:
\begin{description}
    \item[GameCoinModel] - Modelos de moedas do jogo
        \begin{itemize}
            \item \textbf{name} Tipo: CharField - Nome descritivo da moeda;
            \item \textbf{value} Tipo: PositiveIntegerField - Valor da moeda;
            \item \textbf{enabled} Tipo: BooleanField - Estado da moeda (ativo ou desativado).
        \end{itemize}
    \item[GameFinance] - Classe que gerencia as finanças dos usuários
        \begin{itemize}
            \item \textbf{user} Tipo: ForeignKey - Chave estrangeira que identifica o usuário;
            \item \textbf{coin\_model} Tipo: ForeignKey - Modelo da moeda ao qual o registro se refere;
            \item \textbf{amount} Tipo: PositiveIntegerField - Quantidade de moedas que o usuário possui.
        \end{itemize}
    \item[BusBrand] - Marcas de ônibus existentes
        \begin{itemize}
            \item \textbf{label} Tipo: CharField - Nome curto da marca;
            \item \textbf{name} Tipo: CharField - Nome completo da marca;
            \item \textbf{logo} Tipo: ImageField - Logotipo da marca;
            \item \textbf{enabled} Tipo: BooleanField - Estado da marca (ativa ou desativada).
        \end{itemize}
    \item[GameBusModel] - Modelos de ônibus existentes
        \begin{itemize}
            \item \textbf{name} Tipo: CharField - Nome do modelo;
            \item \textbf{bus\_brand} Tipo: ManyToManyField - Marca que possui tal modelo;
            \item \textbf{efficiency} Tipo: PositiveIntegerField - Eficiência do modelo (rendimento por hora);
            \item \textbf{price} Tipo: PositiveIntegerField - preço do modelo de ônibus.
        \end{itemize}
    \item[GameBusAvailability] - Disponibilidade de ônibus para compra
        \begin{itemize}
            \item \textbf{bus\_model} Tipo: ForeignKey - Modelo do ônibus;
            \item \textbf{available\_buses} Tipo: PositiveIntegerField - Quantidades desse modelo disponível para compra.
        \end{itemize}
    \item[GamePersonalBusFleet] - Gerenciamento da frota do usuário
        \begin{itemize}
            \item \textbf{user} Tipo: ForeignKey - Usuário;
            \item \textbf{bus\_model} Tipo: ForeignKey - modelo do ônibus;
            \item \textbf{amount} Tipo: PositiveIntegerField - Quantidade de ônibus que o usuário possui daquele tipo;
            \item \textbf{last\_payment} Tipo: DateTimeField - Quando foi realizado o último ``pagamento'' (rendimento) ao usuário.
        \end{itemize}
\end{description}

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores: %
\begin{itemize}
    \item \textit{GameCoinModelSerializaer};
    \item \textit{GameBusBrandSerializer};
    \item \textit{GameBusModelSerializer};
    \item \textit{GameBusAvailabilitySerializer};
    \item \textit{GameFinanceSerializer};
    \item \textit{GamePersonalBusFleetSerializer}.
\end{itemize}
Até o presente momento não foi necessária nenhuma modificação nos serializadores, que não especificar o tipo de hyperlink do campo ``\textit{usuário}'' nos modelos que possuem tal campo.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Esta camada irá expor os serializadores definidos anteriormente. As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{GameCoinModelViewSet};
    \item \textit{GameBusBrandViewSet};
    \item \textit{GameBusModelViewSet};
    \item \textit{GameBusAvailabilityViewSet};
    \item \textit{GamePersonalBusFleetViewSet};
    \item \textit{GameFinanceViewSet}.
\end{itemize}
As classes \textit{GamePersonalBusFleetViewSet} e \textit{GameFinanceViewSet} retornam apenas os registros referentes ao usuário que está realizando a busca - portanto deve estar autenticado.

\subsubsection{Camada de Template e URLs}
Como não foi criada nenhuma ``página'' publicamente acessível, não foi necessária a criação de template - o \gls{drf} utiliza um template default para a \gls{api} no browser. Quanto às URLs, elas serão definidas no arquivo de URLs do projeto \gls{django}.

\subsubsection{Camada de Adminsitração}
Neste \textit{app} foram expostas todas as classes padrão do \textit{app}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                  Django                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Projeto Django}
Aqui serão descritas as principais configurações do projeto do \gls{django} e também as produções necessárias para integrar os diversos apps.

\subsubsection{Configurações do Django}
O projeto django possui um arquivo de configurações (\textit{settings.py}) que concentra as principais informações do framework, incluindo quais \textit{apps}/\textit{plugins}/\textit{módulos} serão utilizados e configurações dos mesmos.
A seguir apresentamos tais configurações:
\lstinputlisting[language=Python,firstline=32,lastline=46,caption={\textit{APPs} configuradas no projeto}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=48,lastline=51,caption={Configuração específica do \gls{drf}}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=53,lastline=63,caption={\textit{Middlewares} habilitados}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=65,lastline=76,caption={\textit{Template context processors} habilitados}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=78,lastline=83,caption={\textit{Backends} de autenticação},label={cod:back-auth}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=130,lastline=130,caption={Campos de referência no login social},label={cod:social-auth}]{./codes/trilhasp/dev.settings.py.template}
\clearpage
\lstinputlisting[language=Python,firstline=85,lastline=128,caption={Configurações do plugin de login social}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=134,lastline=144,caption={Códigos de autenticação para login social},label={cod:social-auth-keys}]{./codes/trilhasp/dev.settings.py.template}
\lstinputlisting[language=Python,firstline=162,lastline=173,caption={Configurações para base de dados},label={cod:dbinfo}]{./codes/trilhasp/dev.settings.py.template}

Nos trechos de código \ref{cod:back-auth} e \ref{cod:social-auth} pode-se perceber que as linhas referentes à autenticação via \textit{Twitter} estão comentadas/desabilitadas. Isto pois, conforme expresso anteriormente, o \textit{Twitter} não o email do usuário, o que nos impede, neste primeiro momento, de vincular o usuário do twitter com o de outras redes sociais e/ou com o usuário na plataforma.

Tomou-se também o cuidado de se retirar, aqui neste trabalho, os códigos de autenticação do aplicativo com cada uma das plataformas por motivo de segurança, assim como os códigos de acesso ao banco de dados, conforme pode-se obersvar nos Códigos \ref{cod:social-auth} e \ref{cod:dbinfo}, respectivamente.

\lstinputlisting[language=Python,firstline=192,lastline=195,caption={Configurações de arquivos estáticos},label={cod:staticsettings}]{./codes/trilhasp/dev.settings.py.template}

Foi também realizada a configuração da pasta de arquivos estáticos (javascript, css, imagens, vídeos, etc), assim como a URL padrão de arquivos estáticos do \gls{django}, conforme pode ser visto no trecho de código \ref{cod:staticsettings}.

As demais configurações presentes neste arquivo (\textit{settings.py}) são as presentes no padrão do \textit{framework} \gls{django}.

\subsubsection{Definição das rotas (\textit{urls.py})}
As rotas e endereços do projeto foram definidas tanto no core do projeto quanto no módulo \textit{utils}.

No \textit{core} do projeto temos as urls para a área de administração, autenticação (\textit{default} e social), além da autenticação padrão do módulo \gls{rest} e a chamada para as demais urls que se encontram no módulo \textit{utils}.
\lstinputlisting[language=Python,firstline=12,lastline=16,caption={URLs definidas no projeto principal}]{./codes/trilhasp/urls.py}

Já no módulo \textit{utils} definimos as URLs relativas aos \textit{endpoints} de nossa API:
\lstinputlisting[language=Python,firstline=9,lastline=24,caption={Endpoints Padrões da API definidos no módulo \textit{utils}}]{./codes/utils/urls.py}

Conforme sugerido na documentação oficial do \gls{drf}, utilizamos a classe \textit{routers} do \textit{framework}, o que facilita a criação dos endpoints, visto que a cada rota registrada no arquivo de configuração, diversas outras rotas são automaticamente criadas pela classe. Apenas como exemplo, ao se definir a rota para a classe empresa de ônibus, são automaticamente criadas as rotas para \textit{listar todas as empresas de ônibus} e \textit{verificar uma única empresa de ônibus}.

Além disso, também foram inseridas alguns \textit{endpoints} utilizando o padrão \textit{urlpatterns} do \gls{django}. Estes foram criadas por serem \textit{endpoints} diferentes dos criados por padrão pelo \textit{framework}. Um exemplo é o \textit{endpoint} que busca uma linha de ônibus tomando por chave de busca o código da linha de ônibus, no lugar do identificador (chave primária) interno da base de dados.
\lstinputlisting[language=Python,firstline=28,lastline=28,caption={Endpoints para buscar uma linha de ônibus por seu código}]{./codes/utils/urls.py}
Temos ainda o \textit{endpoint} para buscar informações de usuários por seu \textit{username}:
\lstinputlisting[language=Python,firstline=29,lastline=29,caption={Endpoints para buscar um usuário por seu \textit{username}}]{./codes/utils/urls.py}
Por fim, temos ainda um endpoint que busca todos os usuários que estão a uma determinada distância de um determinado ponto (latitude e longitude) e que tenham essa informação atualizada na última hora. Este endpoint ainda será melhor elaborado para permitir que sejam passadas as informações de ``raio'' a ser buscado e ``range'' de horário a ser considerado.
\lstinputlisting[language=Python,firstline=30,lastline=30,caption={Endpoints para buscar usuários ao redor de um ponto}]{./codes/utils/urls.py}

\subsubsection{Serializadores}
No módulo \textit{utils} foi criado, até o momento, apenas um serializador, que diz respeito aos Usuários, que serializa a classe \textit{default} (User) de usuários do \textit{framework} \gls{django}. O nome deste serializador é \textit{UserSerializer} %
Este serializador tem como especifidade tratar o campo password para que o mesmo não seja exposto, nem mesmo a administradores.

\subsubsection{Camada de lógica de negócio (\textit{views})}
No módulo \textit{utils}, até o momento, também foi criada apenas uma view (\textit{UserView}), que expõe a classe criada explicada acima. Esta classe tem como característica permitir apenas o acesso a um determinado registro a usuários que sejam administradores ou ao próprio usuário ao qual o registro se refere.

\subsubsection{Outras funções de utilidade geral}
No módulo \textit{utils} foi criado também, no arquivo \textit{util.py} uma classe que extende a classe de permissões básicas do \gls{drf}, tendo esta sido criada para facilitar a definição de permissão de acesso para ``Administradores ou ao próprio usuário dono do registro''.
\lstinputlisting[language=Python,firstline=5,lastline=12,caption={Classe de permissão para Administradores e para o próprio usuário}]{./codes/utils/util.py}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Nginx & uWSGI                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{nginx \& uWSGI}
Aqui será brevemente descrita a implementação dos servidores web e de aplicação \gls{nginx} e \gls{uwsgi}.

A pilha de serviços mais utilizada para deploy de aplicações \gls{django}, e que utilizaremos nesta aplicação, é a apresentada na Figura \ref{fig:djangostack}.
Para este \textit{deploy} inicial iremos utilizar o tutorial da própria documentação oferecida pela comunidade do \gls{uwsgi}\footnote{\url{http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html}}. Aproveitaremos também para criar um script de deploy padronizado para o projeto.
\diagramaRetrato{django_stack_http.eps}{0.5}{Pilha de serviços do Django}{djangostack}{django-dmq em \url{https://code.google.com/p/django-dmq/wiki/Djangocon2011submission}}{}

Vale destacar que os scripts e configurações descritos a seguir consideram o deploy realizado num servidor dedicado - pode ser um VPS; que utiliza como sistema operacional \textit{debian jessie (8.0)} e terá um usuário chamado \textit{trilhasp}, em cuja home (\textit{/home/trilhasp}) estará a pasta do projeto (\textit{/home/trilhasp/trilhasp}), clonada do repositório git. Destaca-se ainda que este usuário deve possui permissão de ``superusuário'' (sudo) no sistema operacional. Após realizada a instalação e o deploy recomenda-se retirar tal permissão do usuário por motivos de segurança do servidor.

O primeiro passo é realizar a instalação do \gls{uwsgi} e do \gls{nginx} no sistema como um todo, utilizando o comando:
\begin{lstlisting}[caption={Instalando nginx e uwsgi no sistema}]
sudo apt-get install nginx uwsgi
\end{lstlisting}

O passo seguinte é modificar o arquivo de configurações do \gls{django} (\textit{settings.py}) para um servidor de produção, desativando o padrão de DEBUG habilitado. Além disso, para que se configure a opção de Debug para Falso, também é preciso especificar os ``hosts permitidos''. No caso optou-se por permitir apenas o host ``\textit{api.trilhasp.datapublika.com}''. As possíveis variações de endereço, como ``\textit{www.api.trilhasp.datapublika.com}'' ou as variações com terminação ``\textit{.com.br}'' serão tratadas pelo \gls{nginx} e redirecionadas para a primeira.
\lstinputlisting[language=Python,firstline=23,lastline=27,caption={Configuração do Django para Produção}]{./codes/trilhasp/prod.settings.py.template}

Em seguida foram criados os arquivos de configuração do servidor \gls{uwsgi}, sendo eles \textit{uwsgi\_params} e \textit{trilhasp\_uwsgi.ini}.
O primeiro contém apenas algumas configurações padronizadas que não precisam ser alteradas (Anexo \ref{anexo:nginx-uwsgi}, Código \ref{anexo:uwsgi-params}). Já o segundo, que serve para permitir a inicialização do servidor \gls{uwsgi} de forma automática com o boot do sistema operacional, contém configurações necessárias de serem personalizadas.
\lstinputlisting[firstline=1,lastline=22,caption={Configuração de inicialização do uwsgi}]{./codes/trilhasp_uwsgi.ini}

Este arquivo ``\textit{trilhasp\_uwsgi.ini}''  precisa ainda ser linkado ``\textit{/etc/uwsgi/vassals}'' (talvez seja necessário criá-lo com e configurar o \textit{ownership} do diretório para o usuário e grupo \textit{www-data} do servidor web \gls{nginx}). Após é preciso adicionar a linha:
\begin{lstlisting}[language={Python},caption={Inicialização automática do servidor uWSGI}]
/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals --uid www-data --gid www-data
\end{lstlisting}
ao arquivo ``\textit{/etc/rc.local}''. Com esta linha, qualquer script wsgi que seja colocado na pasta será executado. Assim, pode-se ter múltiplas aplicações rodando simultâneamente e, além disso, qualquer alteração no script fará com que o servidor \gls{uwsgi} a identifique e refaça o deploy da mesma no servidor automaticamente.

Agora iremos criar o arquivo de configuração do servidor nginx.
\lstinputlisting[firstline=3,lastline=50,caption={Arquivo de configuração do servidor web nginx}]{./codes/trilhasp_nginx.conf}

Este arquivo deve ser linkado (link simbólico) à pasta ``\textit{/etc/nginx/sites-enabled/}'' e, em seguida, o servidor \gls{nginx} deve ser reiniciado para que as regras sejam aplicadas.

\section{Aplicativo Mobile}\label{sec:spec-appmobile}
Conforme exposto anteriormente, optou-se por utilizar um modelo de desenvolvimento móvel híbrido. Para tanto, escolheu-se o \textit{framework} \gls{ionic}, que integra-se à plataforma \gls{cordova}, que encapsula a aplicação desenvolvida com o \gls{ionic} e simula uma aplicação nativa do celular. É extremamente comum, também, utilizar junto ao \gls{ionic} outro framework, o \gls{angular}, para automatizar ainda mais o processo de desenvolvimento, e essa foi uma escolha que foi seguida pela projeto.

\subsection{Estrutura de telas}
O \textit{app mobile} foi definido em torno de 9 telas, sendo elas:

\subsubsection{Login}
Uma tela de login na qual o usuário pode se cadastrar na plataforma ou realizar o login, com seu login da plataforma ou seus logins sociais (\textit{Facebook} e \textit{Google} até o presente momento.
    
\subsubsection{Principal}
Uma tela principal, com informações sobre os recursos do aplicativo e o respectivo acesso aos mesmos.
    
\subsubsection{QRCode}
A primeira tela do módulo de avaliação foi desenvolvida para que o usuário possa fotografar o \gls{qrcode} do ônibus e iniciar a avaliação do mesmo, conforme pode ser visto na Figura \ref{fig:print-qrcode}.
    
A leitura do \gls{qrcode} será realizada localmente no celular do usuário por meio de uma biblioteca javascript chamada jsqrcode\footnote{\url{https://github.com/LazarSoft/jsqrcode}}.
\diagramaRetrato{print-qrcode.png}{0.24}{Tela do leitor de QRCode}{print-qrcode}{Autoria Própria}{}    

\subsubsection{Avaliação Geral}
Após a escolher o ônibus a ser avaliado o usuário vai para a tela de avaliação geral, na qual dá a sua nota e, se ela for negativa, pode optar por descrever o motivo da nota negativa, conforme pode ser observado na Figura \ref{fig:print-avgeral}.
\diagramaRetrato{print-avgeral.png}{0.24}{Tela de Avaliação Geral}{print-avgeral}{Autoria Própria}{}
    
\subsubsection{Avaliações Específicas}
Em seguida ele é direcionado para a página de avaliações específicas, que contém as 5 avaliações qualitativas definidas no sistema. Todas elas possuem apenas o ``\textit{slider}'' de avaliação. Caso o usuário insira alguma nota negativa, irá ser aberta uma caixa de texto. Apenas uma caixa de texto será apresentada por vez, respectiva à avaliação que o usuário está fazendo no momento. Isso para evitar um \textit{scroll} muito grande na tela. Além disso, também foi definido que todas as avaliações específicas ficariam na mesma página para dar ao usuário uma sensação de que ele terminará mais rapidamente as avaliações, incentivando-o a avaliar. Após finalizar estas avaliações ele será direcionado à página principal, conforme pode ser observado na Figura \ref{fig:print-avespec}.
\diagramaRetrato{print-avespec.png}{0.24}{Tela de Avaliações Específicas}{print-avespec}{Autoria Própria}{}
    
\subsubsection{Mapa}
Nesta tela será apresentado o mapa com todos os usuários conectados no momento.
    
Para uma primeira implementação de rápida prototipagem foi utilizada a biblioteca de mapa oferecida pelo Google (Google Maps). Mas esta será trocada pela biblioteca leaflet.js\footnote{\url{http://leafletjs.com/}}, uma biblioteca javascript livre para produção de mapas, e também os tiles que serão utilizados não serão os oferecidos pelo Google, mas sim os produzidos pela Comunidade OpenStreetMap\footnote{\url{http://www.openstreetmap.org/about}}, que fornece o serviço gratuitamente e é construída por um esforço coletivo de milhares de pessoas.
\diagramaRetrato{print-mapa.png}{0.8}{Tela do Mapa GPS Social}{print-gps-social}{Autoria Própria}{}
    
\subsubsection{Comprar ônibus}
Nesta tela será apresentado ao usuários os ônibus que ele pode comprar para montar sua frota, assim como seu saldo financeiro. Ele poderá optar pelo veículo que deseja adquirir e confirmar a compra. Em seguida ele será direcionado à tela para compartilhar a compra.
    
\subsubsection{Compartilhar nas redes sociais}
Nesta página o usuário será convidado a compartilhar em suas redes sociais a compra que acabou de realizar.
    
\subsubsection{Perfil/Frota Atual}
Nesta página será apresentada ao usuário sua frota atual, quantos ônibus ele possui, de quais modelos, e quanto tempo falta para eles ``renderem'' e retornarem financeiramente ao usuário.

\section{Background}
É fundamental ainda que o aplicativo mobile esteja rodando em background no celular do usuário, para poder manter a informação de geolocalização atualizada e, no futuro, poder enviar notificações ao mesmo. Nas Figuras \ref{fig:print-bkg1} e \ref{fig:print-bkg2} é possível observar o \textit{app} rodando em background no celular.
\diagramaRetrato{print-bkg1.png}{0.8}{Aplicativo Rodando em Background 1}{print-bkg1}{Autoria Própria}{}
\diagramaRetrato{print-bkg2.png}{0.8}{Aplicativo Rodando em Background 2}{print-bkg2}{Autoria Própria}{}

\include{./texto/especificacoes/requisitos-funcionais}
\input{./texto/especificacoes/requisitos-nao-funcionais}
\include{./texto/especificacoes/avaliacoes}