\chapter{Especificação}\label{chp:Especificação}
O projeto foi elaborado de maneira que a interação do usuário ocorra por meio de um aplicativo móvel. Como haverá troca de informações entre os usuários, e também armazenamento de dados advindos dos mesmos, será necessário desenvolver, além do aplicativo móvel, também um servidor de infraestrutura de dados (\textit{backend}).

Neste capítulo serão descritas as especificações e a implementação tanto do aplicativo móvel quanto do servidor de \textit{backend}.

\section{Tecnologias do \textit{Backend}}\label{sec:spec-backend}
Como solução de \textit{backend} foi utilizado o \textit{framework} \gls{django}, que utiliza a linguagem de programação \textbf{Python} e é organizado segundo a \gls{dp} \gls{mvt}, conforme pode ser visto nas Figuras \ref{fig:arqMVT} e \ref{fig:arqDjango}.%
%
\diagramaRetrato{arquitetura-app-django.png}{0.9}{Arquitetura MVT de um APP do framework Django}{arqMVT}{Jeff Croft em {\footnotesize\url{http://www.flickr.com/photos/jcroft/432038560/sizes/o/in/photostream/}} - Acesso em 01/08/2014}{} %TODO TRADUZIR
%
\diagramaRetrato{django-arq2.eps}{1.1}{Arquitetura do framework Django}{arqDjango}{Abhijeet Shekhar em {\footnotesize\url{http://www.slideshare.net/AbhijeetShekhar1/django-39439148}} - Acesso em 01/08/2014}{}

A estrutura de projeto do \textit{framework} é pensada de forma modular, na qual a aplicação é composta por ''\textit{apps}'' independentes que realizam funções específicas e são conectados no projeto, conforme pode ser visto na Figura \ref{fig:multiApps}.%
%
\diagramaRetrato{django-multi-apps.jpg}{0.42}{Arquitetura multi-aplicativos do Django}{multiApps}{Ian Ward em {\footnotesize\url{http://excess.org/article/2007/06/oclug-django-site/}} - Acesso em 01/08/2014}{} %TODO TRADUZIR

Considerando tal arquitetura, foram desenvolvidos os três módulos principais já descritos anteriormente, na Seção \ref{sec:Escopo} (\textbf{Avaliação}, \textbf{Game} e \textbf{GPS social}). Além destes, também foi necessária a criação de um módulo adicional (\textit{utils}) com a finalidade de suprir algumas integrações entre os \textit{apps} sem impactar no isolamento\footnote{Os diversos \textit{apps} de um projeto \gls{django} são construídos para serem completamente independentes entre si, ou seja, são aplicações independentes que trabalham de forma isolada uma das outras, permitindo que sejam utilizadas e reutilizadas em diversos contextos.} entre eles. A função principal deste módulo foi a de definir a \gls{api} \gls{rest} do projeto

A \gls{api} \gls{rest} foi implementada utilizando-se o pacote \gls{drf}%
\footnote{\textit{Django Rest Framework} \url{http://www.django-rest-framework.org} - Acesso em 01/09/2014}. Com o uso do \gls{drf} %
foi necessário desenvolver classes serializadoras%
\footnote{O papel básico de um serializador é transformar um Objeto numa sequência de caracteres, uma \textit{string}, que passa a ser a representação textual do objeto, contendo seus atributos.}%
, cada uma vinculada a um dos modelos de dados a ser exposto (\textit{models}).
Em seguida foi preciso criar as respectivas \textit{views} para os serializadores e um Roteador%
\footnote{Um Roteador nada mais é que um conjunto de regras que verificam um endereço, comparando-o com os endereços cadastrados, e caso o endereço se enquadre em alguma das regras os dados da requisição são repassados a alguma função estipulada na determinada regra.}
(\textit{Router}) com as urls que seriam expostas. Sequer foi necessária a criação de templates, visto que o pacote já fornece um template padrão. O módulo expõe os dados no formato \gls{json}, para além da apresentação na interface web, sem que seja necessário qualquer desenvolvimento ou configuração.

Foi utilizado também o pacote \gls{psa} para permitir a autenticação dos usuários com seus logins de redes sociais. Neste primeiro momento foram disponibilizados os logins via \textit{Facebook}%
\footnote{\url{https://developers.facebook.com/docs/facebook-login/v2.2} - Acesso em 20/08/2014}
e via \textit{Google Social Login}%
\footnote{\url{https://developers.google.com/+/web/signin/} - Acesso em 20/08/2014}, 
ambos utilizando o protocolo de autenticação OAuth 2.0%
\footnote{\url{http://oauth.net/2/} - Acesso em 18/08/2014}.
Neste primeiro momento não foi utilizada a rede social \textit{Twitter} pois a mesma não disponibiliza o e-mail do usuário ao realizar o login, o que impede que possamos vincular a conta da rede social com usuários já cadastrados.

Como o aplicativo lida com dados georreferenciados, para \gls{sgbd} foi escolhido o \textbf{PostgreSQL} com a extensão \textbf{PostGis}, visto que esta é a solução recomendada pelos desenvolvedores do \gls{django}%
\footnote{``PostGIS é recomendado, pois é a solução de código aberto para bases de dados espaciais mais madura e cheia de recursos'' conforme nota em: {\url{https://docs.djangoproject.com/en/1.7/ref/contrib/gis/install/\#spatial-database}} - Acesso em: 25/08/2014},
de sua extensão ``geo'' e da biblioteca python \textit{gdal (Geospatial Data Abstraction Library)}. A solução escolhida permite realizar consultas utilizando critérios de geolocalização como, por exemplo, ``Selecionar todos os registros cuja localização se encontra num raio de X metros do ponto Y'', o que é fundamental para a criação do módulo \textbf{mapa}.

O \textit{framework} \gls{django} por si só não é um servidor web - ele apenas possui um micro-servidor para fins de teste e desenvolvimento%
\footnote{O servidor \textit{lightweight} incluso no \textit{framework} \gls{django} foi desenvolvido apenas com o objetivo de testes de desenvolvimento. Conforme está exposto na documentação oficial: ``NÃO UTILIZE ESTE SERVIDOR EM CONFIGURAÇÃO DE PRODUÇÃO. Ele não passou por auditorias de segurança e testes de performance'' - {\url{https://docs.djangoproject.com/en/1.7/ref/django-admin/\#runserver-port-or-address-port}} - Acesso em 28/08/2014}%
; então faz-se necessário utilizar um servidor web. No presente projeto optou-se pelo \gls{nginx}, o servidor web que tem crescido no ritmo mais acelerado dos que possuem pelo menos 1\% do mercado. Seu ritmo anual médio de crescimento de 2010 a 2014 foi de 43\%, e hoje ele já ocupa a segunda colocação como servidor mais utilizado na internet com 22,6\% do mercado, atrás apenas do Apache, que tem 59\% do mercado mas que tem perdido, em média, 3,71\% de \textit{market share} ao ano, conforme pode ser observado na Figura \ref{fig:nginxmarkershare}.

\diagramaRetrato{market_share_webservers.png}{0.55}{\textit{Market Share} de servidores web}{nginxmarkershare}{W3Techs - Web Technology Surveys {\footnotesize\url{http://w3techs.com/technologies/history_overview/web_server/ms/y}} - Acesso em 01/09/2014}{}
\clearpage
Além dessa grande exposição, e de possuir uma boa documentação%
\footnote{Documentação do NGINX - \url{http://nginx.org/en/docs/} - Acesso em 01/09/2014}, outra vantagem é que ele consegue cumprir as funções de servidor web, proxy reverso%
\footnote{A função de proxy reverso pode ser entendida como a função de um intermediário num processo qualquer de comunicação. O Usuário (ou cliente) faz uma requisição a um endereço web, assumindo que estará se comunicando diretamente com o servidor web que processa a requisição. Entretando, ele (cliente) está se comunicando com o servidor de proxy, que poderá ou não repassar a requisição a um servidor que irá efeticamente processar esta requisição. Caso tenha ocorrido o repasse, a resposta é devolvida ao proxy reverso que a encaminha ao usuário. Uma das grandes vantagens deste modelo é a possibilidade de implementação de arquiteturas de balanceamento entre diversos servidores de processamento. Outra grande vantagem é que, caso a requisição já tenha sido realizada anteriormente, o próprio servidor de proxy reverso pode atuar como um servidor de \textit{cache}, respondendo com a mesma resposta anterior, poupando assim processamento e carga do servidor de processamento.},
além de outros recursos, tornado-o uma ótima alternativa em termos de escalabilidade.

Porém, o \gls{nginx} não consegue ``fornecer'' (processar as requisições e executar os códigos do \textit{framework}) diretamente a aplicação \gls{django}, para tanto é preciso ainda mais um elemento, que é o servidor de aplicações. Para esta função, um dos que apresenta melhor desempenho nos dias de hoje com relação a projetos que utilizam a linguagem de programação Python é o \gls{uwsgi}%
\footnote{\textit{uWSGI vs Gunicorn para requisições assíncronas} \url{https://ivan-site.com/2012/09/benchmark-uwsgi-vs-gunicorn-for-async-workers/} - Acesso em 01/09/2014}$^,$%
\footnote{\textit{uWSGI vs Gunicorn vs node} \url{http://blog.kgriffs.com/2012/12/18/uwsgi-vs-gunicorn-vs-node-benchmarks.html} - Acesso em 01/09/2014}$^,$%
\footnote{\textit{FCGI vs Gunicorn vs uWSGI} \url{http://www.peterbe.com/plog/fcgi-vs-gunicorn-vs-uwsgi} - Acesso em 01/09/2014}.
Dessa maneira, optamos pelo \gls{uwsgi} como servidor de aplicação trabalhando em conjunto com o \gls{nginx} como servidor web.

Por fim, fica como sugestão para o futuro do projeto a utilização do servidor de cache \textit{varnish}%
\footnote{Varnish Servidor de Cache - \url{https://www.varnish-cache.org/} - Acesso em 20/11/2014}, conforme recomendado pela equipe do hosting DigitalOcean%
\footnote{``Como escalar o Django além do básico'' - \url{https://www.digitalocean.com/community/tutorials/how-to-scale-django-beyond-the-basics} - Acesso em 20/11/2014}, para conseguir escalar o projeto sem precisar necessariamente de mais recursos de máquina.

\section{Modelagem de Dados}\label{sec:diagrama-er}
\diagramaRetrato{diagramas_er_bds.eps}{1.2}{Diagrama Entidade Relacionamento}{DiagER}{Autoria Própria}{}
Na Figura \ref{fig:DiagER} encontra-se a modelagem de dados realizada inicialmente no projeto. Esta modelagem não leva em consideração as especificidades do \textit{framework} utilizado, e eventuais diferenças serão expostas na descrição dos \textit{apps}.

Esta modelagem leva em conta cinco grandes grupos de entidades:
    \begin{enumerate*}[label=\itshape\alph*\upshape)]
        \item Ônibus;
        \item Avaliação;
        \item Geolocalização;
        \item Gerais; e
        \item Game.
    \end{enumerate*}.

As entidades do grupo \textbf{ônibus} são as que definem um determinado veículo a ser avaliado pelo usuário do serviço de transporte. Ela conta com duas classes principais, \textit{onibus} e \textit{linhas\_de\_onibus}. A classe relativa à linha de ônibus representa uma determinada linha de ônibus, incluindo trajeto de ida e de volta. Já a classe \textit{onibus} conterá o cadastro de cada veículo e a qual linha este veículo está associado. O atributo \textit{numero\_onibus} deve ser único e é o que será representado no \gls{qrcode} que será digitalizado pelo usuário do aplicativo.

As entidades do grupo \textbf{avaliação} são as que compõe o modelo do módulo de mesmo nome. Nele temos \textit{aval\_tipo\_resposta}, classe que define os tipos possíveis de respostas a serem dadas pelos usuários do aplicativo. Seu objetivo é uniformizar as respostas que as perguntas podem receber. Temos também a classe \textit{aval\_pergunta}, na qual são definidas as perguntas que serão apresentadas aos usuários. A primeira delas, de id=0, deverá ser a pergunta ``geral''. As demais perguntas podem ser adicionadas livremente e ativadas ou inativadas. Por fim, no grupo ainda existe a classe \textit{respostas}. que irá armazenar as respostas enviadas pelos usuários.

Outro grupo que temos é o \textbf{gerais}, que contém informações dos usuários (cadastro, login e permissões).

Temos também o grupo \textbf{geolocalização}, que contém as tabelas que armazenam o registro de localização dos usuários. Para melhorar o desempenho, optou-se por salvar a localização do usuário em duas tabelas distintas. Uma delas, \textit{last\_geolocation}, armazena a última localização de cada usuário. Já a tabela \textit{geolocation\_history} armazenará todas as localizações de cada usuário. Essa opção de duas tabelas distintas foi feita para melhorar o desempenho do banco na geração do mapa do módulo \textbf{GPS Social}, que só precisará buscar informações nesta única tabela com número de registros igual ao número de usuários, e não na tabela que contém todo o histórico de localização de cada usuário. Já esta última tabela poderá ser utilizada, no futuro, para geração de índices e indicadores.

Por último temos o grupo \textbf{game}, que representa as entidades responsáveis pelo armazenamento dos dados do jogo presente no aplicativo. Nele temos algumas entidades ``fundamentais'', ou básicas. Começamos pela classe \textit{game\_tipos\_moedas}, que contém a listagem dos tipos de moedas disponíveis no jogo. Em seguida passamos pela classe \textit{game\_base\_onibus}, que contém dos ônibus disponíveis para serem comprados pelos usuários. A última classe ``básica'' é a \textit{game\_base\_rendimento\_onibus}, que contém o rendimento de cada tipo de ônibus em termos de quantidades das moedas existentes no jogo. Temos ainda duas classes auxiliares, \textit{game\_aux\_tipo\_onibus} e \textit{game\_aux\_marca\_onibus}, que servem de caracterização dos ônibus disponíveis no sistema. Por fim, temos duas classes ligadas aos jogadores e mutáveis ao longo do tempo: \textit{rel\_usuario\_moedas}, que armazena a quantidade de moedas que um determinado usuário possui e \textit{frota\_do\_usuario}, que mantém a informação da frota de ônibus de cada usuário.

\clearpage
\section{Implementação}\label{sec:estrutura-app}
Nesta seção será descrita a rotina de implementação da infraestrutura de \textit{backend} como um todo e a implementação de cada um dos \textit{apps}, assim como do projeto \gls{django} que integra os \textit{apps}. Cada \textit{app} será descrito considerando o \gls{dp} \gls{mvt}.

A implementação completa dos \textit{models}, das \textit{views}, \textit{serializers} e \textit{urls} pode ser encontrada no Anexo \ref{anexo:sources} ou no repositório oficial do projeto\footnote{Repositório Oficial do Projeto: \url{http://github.com/diraol/trilhasp} - Acessado em 15/12/2014}

Com o objetivo de facilitar colaborações e outros trabalhos futuros, o código fonte do projeto utiliza como idioma padrão o inglês, desta forma, os \textit{apps}, módulos, as classes e os atributos utilizarão termos neste idioma que representam o que nesta monografia estiver descrito em português.

\subsection{Setup Inicial}
Para o \textit{setup} inicial do servidor foi criado um \textit{shell script} que realiza toda a instalação. Ele foi desenvolvido e testado para o sistema operacional \textbf{Debian Jessie (8.0)}.

Este \textit{setup} inicial contempla a instalação do \gls{django}, do \gls{sgbd} \textbf{PostgreSQL} (v9.4), com sua extensão de dados espaciais \textbf{PostGis} (v2.1), além dos pacotes necessários para a utilização do recurso de ambientes virtuais (\textit{Virtualenv}) do \textbf{Python}, o que facilita o encapsulamento e a manutenabilidade da aplicação num servidor. Iniciaremos pela listagem dos requisitos necessários para implantação de nosso ambiente.

Requisitos para a utilização de ambientes virtuais: %
\begin{enumerate*}[label=\itshape\alph*\upshape)] 
    \item \mbox{\textit{python-setuptools}};
    \item \mbox{\textit{python-pip}};
    \item \mbox{\textit{python-dev}}
\end{enumerate*}.

Requisitos para a base de dados espaciais e sua integração com o Python: %
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item\mbox{\textit{postgresql-9.4}};
    \item\mbox{\textit{postgresql-contrib-9.4}};
    \item\mbox{\textit{postgresql-9.4-postgis}};
    \item\mbox{\textit{postgresql-server-dev-9.4}};
    \item\mbox{\textit{libpq-dev}};
    \item\mbox{\textit{binutils}};
    \item\mbox{\textit{libproj-dev}};
    \item\mbox{\textit{gdal-bin}};
    \item\mbox{\textit{python-gdal}};
    \item\mbox{\textit{python-psycopg2}}
\end{enumerate*}.

Após instalados os pacotes, o \textit{script} irá realizar a criação de um usuário \textit{trilhasp} no PostgreSQL, na qual será requisitado ao usuário para inserir um \textit{password}, para que, em seguida, seja criada automaticamente a base de dados dentro do \gls{sgbd}, com codificação (\textit{encoding}) UTF-8, e sejam instaladas as extensões de georreferenciamento na base recém criada.

Em seguida, será instalado o pacote \textit{virtualenv} do \textbf{Python}, com o uso da ferramenta de gerenciamento de pacotes \textit{pip}, e é criado um novo ambiente virtual (numa pasta chamada \textbf{venv}), que é ativado e no qual são instalados os demais \textit{requirements} de Python, que ficam definidos no arquivo \textit{requirements.txt}.

Finalizando o \textit{setup} inicial do \gls{django}, o \textit{script} irá executar os comandos para criação das bases de dados, tomando como referência os modelos (\textit{models}) de todas as aplicações listadas nas configurações do \gls{django}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP AVALIAÇÃO                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Avaliação}
No código fonte do projeto este módulo foi chamado de \textit{evaluation}.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:eval-camada-model}
Neste \textit{app} foram criadas as classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{BusCompanies};
    \item \textit{BusLine};
    \item \textit{Buses};
    \item \textit{EVALAnswerModel};
    \item \textit{EVALQuestion}; e
    \item \textit{EVALAnswer}
\end{enumerate*}.
A classe \textit{BusCompanies} contém dados sobre as empresas de ônibus, a classe \textit{BusLine} contém informações sobre as linhas de ônibus, a classe \textit{Buses} possui informações de cadastro dos veículos, a classe \textit{EVALAnswerModel} contém os modelos de respostas possíveis de serem dados e que serão vinculados a uma pergunta da classe \textit{EVALQuestion}, que contém as questões que estarão disponíveis aos usuários e, por fim, a classe \textit{EVALAnswer}, que armazenará as respostas (avaliações) dos usuários.

Na Tabela \ref{tab:model-app-avaliacao} encontram-se os atributos de cada uma das classes, seus tipos e descrições:

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP Avaliação \label{tab:model-app-avaliacao}}    
  }{
    \begin{tabular}{|P{2.9cm}|P{3.2cm}|P{2.5cm}|P{5.4cm}|}
    \toprule
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{2}{2.9cm}{BusCompanies} & company\_name & CharField & Nome da Empresa \\ \cline{2-4}
        & logo & ImageField & Logo da empresa \\ \hline
        \multirow{5}{2.9cm}{BusLine} & bus\_line\_code & CharField & Código da linha do ônibus \\ \cline{2-4}
        & going\_bus\_name & CharField & Nome do trajeto de ida \\ \cline{2-4}
        & return\_bus\_name & CharField & Nome do trajeto de volta \\ \cline{2-4}
        & active & BooleanField & Estado da linha (ativa ou inativa) \\ \cline{2-4}
        & company\_name & ForeignKey & Empresa responsável pela linha \\ \hline
        \multirow{3}{2.9cm}{Buses} & bus\_unique\_number & IntegerField & Número único de cada veículo \\ \cline{2-4}
        & bus\_line\_code & ForeignKey & Código da linha que este ônibus serve \\ \cline{2-4}
        & active & BooleanField & Estado da linha (Ativa ou inativa) \\ \hline
        \multirow{7}{2.9cm}{EVALAnswerModel} & answer & CharField & texto explicativo deste tipo de resposta \\ \cline{2-4}
        & upper\_limit\_text & CharField & Label do valor superior\\ \cline{2-4}
        & middle\_text & CharField & Label do valor central\\ \cline{2-4}
        & lower\_limit\_text & CharField & Label do valor inferior\\ \cline{2-4}
        & uppwer\_limit\_value & IntegerField & Valor do limite superior\\ \cline{2-4}
        & middle\_value & IntegerField & Valor central\\ \cline{2-4}
        & lower\_limit\_Value & IntegerField & Valor do limite inferior\\ \hline
        \multirow{3}{2.9cm}{EVALQuestion} & question & CharField & Texto da questão que será apresentado ao usuário\\ \cline{2-4}
        & answer & ForeignKey & Tipo da resposta para esta pergunta\\ \cline{2-4}
        & enabled & BooleanField & Estado da pergunta (ativa ou inativa)\\ \hline
        \multirow{7}{2.9cm}{EVALAnswer} & question & ForeignKey & Questão \\ \cline{2-4}
        & user & ForeignKey & Usuário respondente\\ \cline{2-4}
        & timestamp & DateTimeField & Data e horário da resposta\\ \cline{2-4}
        & answer\_value & IntegerField & Valor numérico da resposta\\ \cline{2-4}
        & answer\_text & CharField & Texto inserido pelo usuário\\ \cline{2-4}
        & bus\_unique\_number & ForeignKey & Número único do ônibus\\ \cline{2-4}
        & geolocation & PointField & Geolocalização do usuário no momento da resposta (ex.: \textit{POINT( lng lat )})\\
    \bottomrule
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}

\subsubsection{Serializadores}
Para a criação da \gls{api} o \gls{drf} requer que o desenvolvedor crie um (ou mais) serializador(es) para cada classe que se deseja expor e, em seguida, que sejam criadas as views que utilizam esses serializadores. Assim, para este \textit{app} foram criados os seguintes serializadores: %
\begin{itemize}
    \item \textit{BusCompaniesSerializer};
    \item \textit{BusLineSerializer};
    \item \textit{BusesSerializer};
    \item \textit{EVALAnswerModelSerializer};
    \item \textit{EVALQuestionSerializer}; e
    \item \textit{EVALAnswerSerializer}.
\end{itemize}

Todos eles foram criados como extensões da classe \textit{serializers.HyperlinkedModelSerializer}%
\footnote{Classe \textit{HyperlinkedModelSerializer} - \url{http://www.django-rest-framework.org/api-guide/serializers/\#hyperlinkedmodelserializer} - Acesso em 15/09/2014}%
, o que faz com que a \gls{api} exposta faça o link entre objetos que são chave-estrangeira e o objeto que está sendo mostrado. Além disso, no serializador \textit{BusesSerializer}, que serializa a classe \textit{BusLine} foi definido como ``campo de busca'' (\textit{lookup\_field}), ou ``campo de referência'', o atributo ``\textit{bus\_line\_code}'', de forma que a busca pelos ônibus na API possa ser realizada pelo código da linha de ônibus, ao invés de um parâmetro de id arbitrário.

\subsubsection{Camada de lógica de negócio (\textit{views})}\label{subsubsec:eval-camada-view}
Esta camada irá expor os serializadores definidos anteriormente. As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{BusCompanyViewSet};
    \item \textit{BusLineViewSet};
    \item \textit{BusesViewSet};
    \item \textit{EVALAnswerModelViewSet};
    \item \textit{EVALQuestionViewSet}; e
    \item \textit{EVALAnswerViewSet}.
\end{itemize}

Estas classes foram definidas como extensões da classe ViewSet do \gls{drf}, o que já contempla automaticamente a criação de \textit{views} para lista de resultados e também para um resultado único em cada visão.

Na definição destas classes podemos especificar quais campos serão expostos na \gls{api}, as permissões de acesso, caso se deseje uma diferente da presente no arquivo de configurações do \gls{django}. Outra opção que pode ser configurada nesta etapa é a definição de qual será o campo (atributo) que será utilizado para buscas, caso deseje-se algum diferente do padrão (chave primária da classe).

Neste app apenas a classe \textit{BusLineViewSet} sofreu uma modificação para além do padrão. Nela foi definido o campo \textit{bus\_line\_code} como sendo o campo de busca dos objetos.

\subsubsection{Camada de Adminsitração}
O \gls{django} oferece por padrão um módulo de administração da aplicação, bastando ativá-lo no arquivo de configurações. Em seguida, para cada \textit{app} é necessário registrar quais são as classes (do modelo) que estarão disponíveis para administração, e, eventualmente, fazer alguma personalização na forma como os campos/atributos da classe são apresentados no navegador.

No caso deste \textit{app} todas as classes foram expostas e ainda adicionou-se uma configuração para que a informação georreferenciada fosse apresentada num \textit{widget}%
\footnote{Um \textit{widget} é um componente de interface gráfica de usuário. Um campo de texto é um \textit{widget} que apresenta informações no formato de texto. Podemos ainda ter \textit{widgets} do tipo \textit{range}, no qual o usuário escolhe um valor numérico num determinado intervalo, do tipo \textit{date}, no qual o usuário seleciona uma data, dentre outros.}
de mapa, ao invés de se apresentar uma coordenada apenas. Esta configuração encontra-se no arquivo \textit{admin.py} do \textit{app} e também está disponível no Anexo \ref{anexo:sources}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP GPSSocial                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP GPSSocial}
Agora veremos o \textit{app} responsável pelo mapa de GPS Social, chamado \textit{demandmap} na implementação do projeto.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:gps-camada-model}
Neste \textit{app} foram criadas as seguintes classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{GEOHistoryPosition}; e
    \item \textit{GEOLastPosition}
\end{enumerate*}.
Conforme dito anteriormente, a classe \textit{GEOHistoryPosition} armazena o histórico de localizações de todos os usuários, enquanto a classe \textit{GEOLastPosition} armazena apenas a última localização de cada usuário. O motivo desta escolha é para que se possa manter todo registro de localização dos usuários para fins de estudos e pesquisas sobre o comportamento dos mesmos, sem comprometer o desempenho da aplicação, que utilizará apenas a última localização.

A seguir, na Tabela \ref{tab:model-app-gps-social}, são apresentados os atributos, seus tipos e descrições, para cada uma das classes:

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP GPSSocial \label{tab:model-app-gps-social}}    
  }{
    \begin{tabular}{|P{3.1cm}|P{3cm}|P{2.5cm}|P{5.4cm}|}
    \toprule
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{3}{3.1cm}{GEOPositionHistory} & user & ForeignKey & Usuário \\ \cline{2-4}
        & geolocation & PointField & Localização do Usuário\\ \cline{2-4}
        & timestamp & DateTimeFIeld & Horário do registro\\ \hline
        \multirow{3}{3.1cm}{GEOLastPosition} & user & ForeignKey & Usuário \\ \cline{2-4}
        & geolocation & PointField & Última localização do Usuário\\ \cline{2-4}
        & timestamp & DateTimeFIeld & Horário do registro\\
    \bottomrule
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores:
\begin{itemize}
    \item \textit{GEOLastPositionSerializer};
    \item \textit{GEOLastAnonPositionSerializer}; e
    \item \textit{GEOHistoryPositionSerializer}.
\end{itemize}

Os serializadores \textit{GEOLastPositionSerializer} e \textit{GEOLastAnonPositionSerializer} são extensões da classe \mbox{\textit{GeoFeatureModelSerializer}}%
\footnote{Classe \textit{GeoFeatureModelSerializer} do módulo \textit{DjangoRestFramework-gis} - \url{https://pypi.python.org/pypi/djangorestframework-gis/0.2} - Acesso em 15/09/2014},
e o serializador \mbox{\textit{GEOHistoryPositionSerializer}} é uma extensão da classe \mbox{\textit{HyperlinkedModelSerializer}}.

Aqui nota-se que há mais serializadores que classes no modelo. Isto ocorreu pois foi criado um serializador (\textit{GEOLastAnonPositionSerializer}) para oferecer as informações dos usuários de forma anonimizada, garantindo a privacidade dos usuários. Esta anonimização foi feita escolhendo-se os campos que seriam apresentados pelo serializador, sendo que o campo \textit{user} não foi adicionado à lista. Além disso, nestes serializadores também foi necessário identificar o campo \textit{geolocation} como sendo um campo do tipo \textit{geo}, para que o serializador saiba a melhor forma de serializar estes dados.

Outras duas mudanças realizadas nestes serializadores não anônimos foi a definição de que o campo de busca seria o \textit{username}.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Aqui definem-se as \textit{views} criadas que servem para expor as classes serializadoras: %
\begin{itemize}
    \item \textit{GEOLastPositionViewSet};
    \item \textit{LastUserPosition};
    \item \textit{LastUsersAtPosition}; e
    \item \textit{GEOHistoryPositionViewSet}.
\end{itemize}

Aqui novamente percebemos quatro classes. A classe \textit{GEOLastPositionViewSet} retorna todos os resultados da última localização de cada usuário%
\footnote{Na classe \textit{GEOLastPositionViewSet} ainda é necessário definir o o horário para que se filtre os resultados, para que não se tenha resultados muito desatualizados. Este filtro ocorrerá no próprio \textit{queryset} da classe.}, sendo que se o usuário que requisitou a informação foi um administrador, os objetos retornados conterão o campo com o nome do usuário de cada registro, e se não for administrador não será retornado o campo com a informação de qual usuário é referente a cada registro.

O campo \textit{GEOHistoryPositionViewSet} não apresenta qualquer configuração especial. Já a classe \textit{LastUsersAtPosition} foi criada para retornar os registros (anonimizados sem o campo de usuário) ao redor de uma determinada posição que tenham sido atualizados na última hora%
\footnote{Optou-se pela última hora apenas como exemplo, este valor pode ser ajustado, mas ainda está \textit{hardcoded}, o ideal é que fosse um dos parâmetros da requisição},
enquanto a classe \textit{LastUserPosition} retorna a última localização de um determinado usuário, de acordo com seu \textit{username}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                 APP Game                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Game}

\subsubsection{Camada de Acesso a Dados (\textit{model})}
Neste app foram criadas as seguintes classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{GameCoinModel};
    \item \textit{GameFinance};
    \item \textit{BusBrand};
    \item \textit{GameBusModel};
    \item \textit{GameBusAvailability}; e
    \item \textit{GamePersonalBusFleet}
\end{enumerate*}.
A Classe \textit{GameCoinModel} representa os tipos existentes de moedas no jogo, a classe \textit{GameFinance} representa as finanças dos usuários - quantas moedas de cada tipo o usuário possui; a classe \textit{BusBrand} contém as marcas de ônibus existentes. A classe \textit{GameBusModel} contém os modelos de ônibus disponíveis para serem comprados, enquanto a \textit{GameBusAvailability} contém a quantidade de cada um disponível para compra pelos usuários. Por fim, a classe \textit{GamePersonalBusFleet} contém quantos ônibus de cada tipo cada usuário possui, mantendo a informação da frota de cada usuário.

Na tabela \ref{tab:model-app-game} encontram-se os atributos de cada uma das classes, seus tipos e descrições.

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP Game \label{tab:model-app-game}}    
  }{
    \begin{tabular}{|P{3.5cm}|P{2.6cm}|P{2.4cm}|P{5.4cm}|}
    \toprule
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{3}{3.5cm}{GameCoindModel} & name & CharField & Nome descritivo da moeda \\ \cline{2-4}
            & value & IntegerField & Valor (inteiro) da moeda\\ \cline{2-4}
            & enabled & BooleanField & Se a moeda está ativa ou inativa\\ \hline
        \multirow{3}{3.5cm}{GameFinance} & user & ForeignKey & Usuário \\ \cline{2-4}
            & coin\_model & ForeignKey & Modelo da moeda\\ \cline{2-4}
            & amount & IntegerField & Quantidade de moedas que o usuário possui\\ \hline
        \multirow{4}{3.5cm}{BusBrand} & label & CharField & Nome curto da empresa\\ \cline{2-4}
            & name & CharField & Nome completo da empresa\\ \cline{2-4}
            & logo & ImageField & Logotipo da marca\\ \cline{2-4}
            & enabled & BooleanField & Se o registro está ativo ou inativo\\ \hline
        \multirow{4}{3.5cm}{GameBusModel} & name & CharField & Nome do modelo\\ \cline{2-4}
            & bus\_brand & ForeignKey & Marca da empresa\\ \cline{2-4}
            & efficiency & IntegerField & Rendimento por hora do modelo\\ \cline{2-4}
            & price & IntegerField & Preço do modelo de ônibus\\ \hline
        \multirow{2}{3.5cm}{GameBusAvailability} & bus\_model & ForeignKey & Modelo do ônibus\\ \cline{2-4}
            & available\_buses & IntegerField & Quantidade do modelo disponível para venda\\ \hline
        \multirow{4}{3.5cm}{GamePersonalBusFleet} & user & ForeignKey & Usuário\\ \cline{2-4}
            & bus\_model & ForeignKey & Modelo do ônibus\\ \cline{2-4}
            & amount & IntegerField & Quantidade de ônibus daquele modelo que o usuário possui\\ \cline{2-4}
            & last\_payment & DateTimeField & Quando foi realizado o último ``pagamento'' ao usuário, referente a este tipo de ônibus\\
    \bottomrule
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores:%
\begin{itemize}
    \item \textit{GameCoinModelSerializaer};
    \item \textit{GameBusBrandSerializer};
    \item \textit{GameBusModelSerializer};
    \item \textit{GameBusAvailabilitySerializer};
    \item \textit{GameFinanceSerializer}; e
    \item \textit{GamePersonalBusFleetSerializer}.
\end{itemize}

Até o presente momento a única modificação necessária dos serializadores se deu nas classes \textit{GameFinanceSerializer} e \textit{GamePersonalBusFleetSerializer}, de forma que o atributo \textit{user} fosse utilizado como campo de busca de registros.

\subsubsection{Camada de lógica de negócio (\textit{views})}
As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{GameCoinModelViewSet};
    \item \textit{GameBusBrandViewSet};
    \item \textit{GameBusModelViewSet};
    \item \textit{GameBusAvailabilityViewSet};
    \item \textit{GamePersonalBusFleetViewSet}; e
    \item \textit{GameFinanceViewSet}.
\end{itemize}

Como as classes \textit{GamePersonalBusFleetViewSet} e \textit{GameFinanceViewSet} retornam apenas os registros referentes ao usuário que está realizando a busca - portanto este deve estar autenticado.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                APP Utils                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Utils}
Este é o módulo que foi criado com o objetivo de unir os demais módulos do projeto.

\subsubsection{Funções auxiliares}
No arquivo \textit{util.py} foi criada uma classe adicional, baseada na classe padrão de permissões do módulo \gls{drf}, para que apenas usuários com permissões administrativas possam acessar informações pessoais, ou o próprio usuário. O nome desta classe é \textit{IsStaffOrTargetUser}, e ela foi utilizada nas \textit{views} anteriormente descritas.

Outras ``funções'' auxiliares que possam vir a ser necessárias e não sejam restritas a um módulo específico devem ser adicionadas neste arquivo.

\subsection{Serializadores}
Aqui foi criado o serializador para a classe padrão do \gls{django} referente aos usuários do sistema. Esta classe serializadora foi nominada de \textit{UserSerializer}. Ela possui uma configuração para definir o campo de senha (\textit{password}) como somente leitura, de forma que a informação da senha nunca seja enviada ao \textit{frontend} ou via \gls{api}. Outra modificação realizada nesta classe foi a criação de uma função (\textit{restore\_object}) para salvar a senha (no caso de alteração) utilizando a função padrão \textit{set\_password}, evitando assim que a senha seja salva em texto plano.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Nesta camada foi criada a view (\textit{UserView}) para o serializador \textit{UserSerializer}. Nesta foi definido que o campo de busca para encontrar registros seria o nome de usuário (\textit{username}), além da permissão para administradores e para o próprio usuário dono do registro.

\subsection{Camada de Template}
Assim como em todos os outros módulos, nenhuma alteração foi realizada em termos de templates, visto que todas as páginas irão utilizar o template default do módulo \gls{drf}.

\subsection{URLs}\label{subsec:util-urls}
Aqui estão descritas as configurações relativas aos endereços (\textit{endpoints}\footnote{\textit{endpoint} é o termo utilizado para designar um endereço válido de uma \gls{api} que irá retornar algum dado}) aos quais a \gls{api} irá responder.
A maioria destes endereços foi definida utilizando a classe \textit{router} do próprio \textit{framework}, que se responsabiliza por criar todas as urls necessárias para cada \textit{view} registrada no \textit{router}, segundo um endereço inicial. Como alguns endereços foram criados fora do padrão básico do \textit{framework}, estes foram definidos seguindo o padrão de endereçamento do próprio \gls{django}.

Para se registrar um endereço no \textit{router}, a sintaxe é:
\begin{lstlisting}[language=Python,caption={Sintaxe padrão para registro de endereço no \textit{router}}]
router.register(r'user', UserView)
\end{lstlisting}
No exemplo acima, a view UserView será acessada ao se realizar uma requisição no \textit{endpoint} \textbf{user}. No caso do projeto, tomando a url base como sendo \textit{http://api.trilhasp.datapublika.com/v1/}, o \textit{endpoint} para acessar a view \textit{UserView} será \textit{http://api.trilhasp.datapublika.com/v1/user}, e este retornará todos os usuários cadastrados no sistema. O \textit{router} irá criar ainda uma série de outros endpoints baseados neste que foi definido, como, por exemplo, 
\textit{http://api.trilhasp.datapublika.com/v1/user/<username>}, que irá retornar as informação do usuário \textit{username}.

Os \textit{endpoints} que precisaram ser definidas fora do \textit{router}, seguindo o padrão do \gls{django}, foram as seguintes:
\begin{lstlisting}[language=Python,caption={EndPoints definidos manualmente}]
    url(r'^evaluation/bus/line/(?P<bus_line_code>[0-9A-Za-z--]+)/', BusLineViewSet.as_view(), name='bus-line'),
    
    url(r'^position/last/user/(?P<user>[^/.]+)/$', LastUserPosition.as_view(), name='lastlocation-detail'),
    
    url(r'^position/last/users/(?P<lon>(-?\d+\.\d+))_(?P<lat>(-?\d+\.\d+))/$', LastUsersAtPosition.as_view(), name='lastuserslocation-detail'),
\end{lstlisting}

O primeiro deles é o que permite que seja realizada a busca de linhas de ônibus pelo número da linha, ao invés do ID interno da mesma. O segundo é o que permite que seja buscada a última localização de um usuário por meio de seu \textit{username}.

E, por fim, temos o \textit{endpoint} que permite que sejam buscados todos os usuários ao redor de uma certa localização em termos de longitude e latitude. Um exemplo de url que se adequa a este \textit{endpoint} é:
``\textit{http://api.trilhasp.datapublika.com/v1/position/last/users/-23.745\_-5.888}''. Neste caso, -23.745 representa a longitude, enquanto -5.888 representa a latitude da localização desejada, e o separador entre latitude e longitude é o símbolo de ``\_'' (\textit{underline}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                  Django                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Projeto Django}
Aqui serão descritas as principais configurações do projeto do \gls{django} e também as produções necessárias para integrar os diversos apps.

\subsubsection{Configurações do Django}
O projeto \gls{django} possui um arquivo de configurações (\textit{settings.py}) que concentra as principais informações do \textit{framework}, incluindo quais \textit{apps}/\textit{plugins}/\textit{módulos} serão utilizados e configurações dos mesmos. A seguir estarão descritas as modificações que foram realizadas com relação ao arquivo padrão do \textit{framework}.

Com relação à configuração de aplicações (\textit{apps}) a serem utilizadas, os seguintes \textit{apps} foram adicionados à lista ``INSTALED\_APPS'':
    \begin{enumerate*}[label=\itshape\alph*\upshape)]
        \item \textit{django.contrib.gis};
        \item \textit{evaluation};
        \item \textit{game};
        \item \textit{demandmap};
        \item \textit{rest\_framework};
        \item \textit{utils}; e
        \item \textit{social.apps.django\_app.default}.
    \end{enumerate*}

Foi também adicionada uma nova variável ao arquivo para configuração do \gls{drf}, chamada ``REST\_FRAMEWORK'', na qual foram definidas a permissão padrão das classes (serializadores e \textit{views}) e também a paginação dos resultados - quantos resultados serão exibidos por página para cada busca realizada na API.

Outra modificação realizada foi na variável ``MIDDLEWARE\_CLASSES'', na qual foram adicionados diversas classes, principalmente as ligadas a autenticação social e ao módulo \textit{django-cors-headers}%
\footnote{\textit{Cross-origin resource sharing} (CORS) ou \textbf{compartilhamento de recursos entre-origens} é uma especificação de uma tecnologia de navegadores que define meios para um servidor permitir que seus recursos sejam acessados por uma página web de um domínio diferente do domínio do próprio servidor. Por padrão os navegadores de internet não permitem que uma página acesse recursos de outras páginas (outro endereço web). Com as corretas configurações de ambos os lados (página que está tentando acessar o recurso e servidor que provê o recurso) esta comunicação pode ser corretamente efetivada. \url{http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/} - Acesso em 25/11/2014} do \gls{django}.

Adicionou-se uma variável para permitir a comunicação entre endereços \gls{cors} com a diretiva \textit{CORS\_ALLOW\_CREDENTIALS}; foram configurados os \textit{backends} de autenticação do django com a diretiva \textit{AUTHENTICATION\_BACKENDS}; foi adicionado o pipeline\footnote{Sequência de ``comandos'' a serem executados} de autenticação do módulo de autenticação social com a diretiva \textit{SOCIAL\_AUTH\_PIPELINE}, assim como os campos a serem utilizados como referência para se criar a relação entre um ``usuário de rede social'' e um usuário já existente no sistema com a diretiva \textit{SOCIAL\_AUTH\_ADMIN\_USER\_SEARCH\_FIELDS}; foram adicionadas informações de autenticação da aplicação com os servidores de autenticação das redes sociais.

Houve também a configuração de parâmetros de acesso à base de dados na diretiva \textit{DATABASES}, adição da versão do \textit{POSTGIS}, configuração do idioma padrão a ser utilizado, bem como do timezone, e a configuração de endereços de arquivos estáticos (css, javascript, imagens, etc) nas diretivas \textit{STATIC\_ROOT} e \textit{STATIC\_URL}, sendo a primeira o endereço absoluto\footnote{Endereço absoluto é o endereço de uma pasta ou arquivo, a partir da raiz do sistema operacional, no próprio equipamento no qual a aplicação está sendo executada.} da pasta de arquivos estáticos e a segunda o complemento da URL no qual os arquivos serão acessados.

\subsubsection{Definição das rotas}
As rotas e endereços do projeto foram definidas tanto no core do projeto quanto no módulo \textit{utils}, conforme exposto na Seção \ref{subsec:util-urls}. Todas as configurações de endereçamento se encontram nos arquivos nominados \textit{urls.py}. No caso deste projeto utilizamos dois arquivos para tais configurações, o primeiro deles é o presente na pasta \textit{trilhasp}, do próprio projeto, e o segundo é o presente no módulo \textit{utils}.

No arquivo presente na pasta \textit{trilhasp} temos as urls para a área de administração, autenticação (\textit{default} e social), além da autenticação padrão da \gls{api} via módulo \gls{rest} e a chamada para as demais urls da API, que se encontram no arquivo do módulo \textit{utils}.

Conforme sugerido na documentação oficial do \gls{drf}, utilizamos a classe \textit{routers} do \textit{framework}, o que facilita a criação dos endpoints, visto que a cada rota registrada no arquivo de configuração, diversas outras rotas são automaticamente criadas pela classe. Apenas como exemplo, ao se definir a rota para a classe empresa de ônibus, são automaticamente criadas as rotas para \textit{listar todas as empresas de ônibus} e \textit{verificar uma única empresa de ônibus}.

Todas as regras de endereçamento contantes na variável \textit{urlpatterns} dos arquivos de configuração de endereços (\textit{urls.py}) podem ser definidas em termos absolutos ou utilizando expressões regulares. Quando uma regra é iniciada por ``\textit{r'....}'' ela será entendida como uma expressão regular, que será comparada com a URL das requisições dos usuários da aplicação.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Nginx & uWSGI                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{NGINX \& uWSGI}
Aqui será brevemente descrita a implementação dos servidores web e de aplicação \gls{nginx} e \gls{uwsgi}.

A pilha de serviços mais utilizada para deploy de aplicações \gls{django}, e que utilizaremos nesta aplicação, é a apresentada na Figura \ref{fig:djangostack}.
Para este \textit{deploy} inicial iremos utilizar o tutorial da própria documentação oferecida pela comunidade do \gls{uwsgi}\footnote{\url{http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html}}. Aproveitaremos também para criar um script de deploy padronizado para o projeto.
\diagramaRetrato{django_stack_http.eps}{0.5}{Pilha de serviços do Django}{djangostack}{django-dmq em \url{https://code.google.com/p/django-dmq/wiki/Djangocon2011submission}}{}

Vale destacar que os scripts e configurações descritos a seguir consideram o deploy realizado num servidor dedicado - pode ser um VPS; que utiliza como sistema operacional \textit{debian jessie (8.0)} e terá um usuário chamado \textit{trilhasp}, em cuja home (\textit{/home/trilhasp}) estará a pasta do projeto (\textit{/home/trilhasp/trilhasp}), clonada do repositório git. Destaca-se ainda que este usuário deve possui permissão de ``superusuário'' (sudo) no sistema operacional. Após realizada a instalação e o deploy recomenda-se retirar tal permissão do usuário por motivos de segurança do servidor.

O primeiro passo é realizar a instalação do \gls{uwsgi} e do \gls{nginx} no sistema como um todo, utilizando o comando:
\begin{lstlisting}[caption={Instalando NGINX e uWSGI no sistema}]
sudo apt-get install nginx uwsgi
\end{lstlisting}

O passo seguinte é modificar o arquivo de configurações do \gls{django} (\textit{settings.py}) para um servidor de produção, desativando o padrão de DEBUG habilitado. Além disso, para que se configure a opção de Debug para Falso, também é preciso especificar os ``hosts permitidos''. No caso optou-se por permitir apenas o host ``\textit{api.trilhasp.datapublika.com}''. As possíveis variações de endereço, como ``\textit{www.api.trilhasp.datapublika.com}'' ou as variações com terminação ``\textit{.com.br}'' serão tratadas pelo \gls{nginx} e redirecionadas para a primeira.
\lstinputlisting[language=Python,firstline=23,lastline=27,caption={Configuração do Django para Produção}]{./codes/trilhasp/prod.settings.py.template}

Em seguida foram criados os arquivos de configuração do servidor \gls{uwsgi}, sendo eles \textit{uwsgi\_params} e \textit{trilhasp\_uwsgi.ini}.
O primeiro contém apenas algumas configurações padronizadas que não precisam ser alteradas (Anexo \ref{anexo:nginx-uwsgi}, Código \ref{anexo:uwsgi-params}). Já o segundo, que serve para permitir a inicialização do servidor \gls{uwsgi} de forma automática com o boot do sistema operacional, contém configurações necessárias de serem personalizadas.
\lstinputlisting[firstline=1,lastline=22,caption={Configuração de inicialização do uwsgi}]{./codes/trilhasp_uwsgi.ini}

Este arquivo ``\textit{trilhasp\_uwsgi.ini}''  precisa ainda ser linkado ``\textit{/etc/uwsgi/vassals}'' (talvez seja necessário criá-lo com e configurar o \textit{ownership} do diretório para o usuário e grupo \textit{www-data} do servidor web \gls{nginx}). Após é preciso adicionar a linha:
\begin{lstlisting}[language={Python},caption={Inicialização automática do servidor uWSGI}]
/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals --uid www-data --gid www-data
\end{lstlisting}
ao arquivo ``\textit{/etc/rc.local}''. Com esta linha, qualquer script wsgi que seja colocado na pasta será executado. Assim, pode-se ter múltiplas aplicações rodando simultâneamente e, além disso, qualquer alteração no script fará com que o servidor \gls{uwsgi} a identifique e refaça o deploy da mesma no servidor automaticamente.

Agora iremos criar o arquivo de configuração do servidor \gls{nginx}.
\lstinputlisting[firstline=3,lastline=50,caption={Arquivo de configuração do servidor web NGINX}]{./codes/trilhasp_nginx.conf}

Este arquivo deve ser linkado (link simbólico) à pasta ``\textit{/etc/nginx/sites-enabled/}'' e, em seguida, o servidor \gls{nginx} deve ser reiniciado para que as regras sejam aplicadas.

\section{Aplicativo Mobile}\label{sec:spec-appmobile}
Conforme exposto anteriormente, optou-se por utilizar um modelo de desenvolvimento móvel híbrido. Para tanto, escolheu-se o \textit{framework} \gls{ionic}, que integra-se à plataforma \gls{cordova}, que encapsula a aplicação desenvolvida com o \gls{ionic} e simula uma aplicação nativa do celular. É extremamente comum, também, utilizar junto ao \gls{ionic} outro framework, o \gls{angular}, para automatizar ainda mais o processo de desenvolvimento, e essa foi uma escolha que foi seguida pela projeto.

\subsection{Estrutura de telas}
O \textit{app mobile} foi definido em torno de 9 telas, sendo elas:

\subsubsection{Login}
Uma tela de login na qual o usuário pode se cadastrar na plataforma ou realizar o login, com seu login da plataforma ou seus logins sociais (\textit{Facebook} e \textit{Google} até o presente momento.
    
\subsubsection{Principal}
Uma tela principal, com informações sobre os recursos do aplicativo e o respectivo acesso aos mesmos.
    
\subsubsection{QRCode}
A primeira tela do módulo de avaliação foi desenvolvida para que o usuário possa fotografar o \gls{qrcode} do ônibus e iniciar a avaliação do mesmo, conforme pode ser visto na Figura \ref{fig:print-qrcode}.
    
A leitura do \gls{qrcode} será realizada localmente no celular do usuário por meio de uma biblioteca javascript chamada jsqrcode\footnote{\url{https://github.com/LazarSoft/jsqrcode}}.
\diagramaRetrato{print-qrcode.png}{0.24}{Tela do leitor de QRCode}{print-qrcode}{Autoria Própria}{}    

\subsubsection{Avaliação Geral}
Após a escolher o ônibus a ser avaliado o usuário vai para a tela de avaliação geral, na qual dá a sua nota e, se ela for negativa, pode optar por descrever o motivo da nota negativa, conforme pode ser observado na Figura \ref{fig:print-avgeral}.
\diagramaRetrato{print-avgeral.png}{0.24}{Tela de Avaliação Geral}{print-avgeral}{Autoria Própria}{}
    
\subsubsection{Avaliações Específicas}
Em seguida ele é direcionado para a página de avaliações específicas, que contém as 5 avaliações qualitativas definidas no sistema. Todas elas possuem apenas o ``\textit{slider}'' de avaliação. Caso o usuário insira alguma nota negativa, irá ser aberta uma caixa de texto. Apenas uma caixa de texto será apresentada por vez, respectiva à avaliação que o usuário está fazendo no momento. Isso para evitar um \textit{scroll} muito grande na tela. Além disso, também foi definido que todas as avaliações específicas ficariam na mesma página para dar ao usuário uma sensação de que ele terminará mais rapidamente as avaliações, incentivando-o a avaliar. Após finalizar estas avaliações ele será direcionado à página principal, conforme pode ser observado na Figura \ref{fig:print-avespec}.
\diagramaRetrato{print-avespec.png}{0.24}{Tela de Avaliações Específicas}{print-avespec}{Autoria Própria}{}
    
\subsubsection{Mapa}
Nesta tela será apresentado o mapa com todos os usuários conectados no momento.
    
Para uma primeira implementação de rápida prototipagem foi utilizada a biblioteca de mapa oferecida pelo Google (Google Maps). Mas esta será trocada pela biblioteca leaflet.js\footnote{\url{http://leafletjs.com/}}, uma biblioteca javascript livre para produção de mapas, e também os tiles que serão utilizados não serão os oferecidos pelo Google, mas sim os produzidos pela Comunidade OpenStreetMap\footnote{\url{http://www.openstreetmap.org/about}}, que fornece o serviço gratuitamente e é construída por um esforço coletivo de milhares de pessoas.
\diagramaRetrato{print-mapa.png}{0.8}{Tela do Mapa GPS Social}{print-gps-social}{Autoria Própria}{}
    
\subsubsection{Comprar ônibus}
Nesta tela será apresentado ao usuários os ônibus que ele pode comprar para montar sua frota, assim como seu saldo financeiro. Ele poderá optar pelo veículo que deseja adquirir e confirmar a compra. Em seguida ele será direcionado à tela para compartilhar a compra.
    
\subsubsection{Compartilhar nas redes sociais}
Nesta página o usuário será convidado a compartilhar em suas redes sociais a compra que acabou de realizar.
    
\subsubsection{Perfil/Frota Atual}
Nesta página será apresentada ao usuário sua frota atual, quantos ônibus ele possui, de quais modelos, e quanto tempo falta para eles ``renderem'' e retornarem financeiramente ao usuário.

\section{Background}
É fundamental ainda que o aplicativo mobile esteja rodando em background no celular do usuário, para poder manter a informação de geolocalização atualizada e, no futuro, poder enviar notificações ao mesmo. Nas Figuras \ref{fig:print-bkg1} e \ref{fig:print-bkg2} é possível observar o \textit{app} rodando em background no celular.
\diagramaRetrato{print-bkg1.png}{0.8}{Aplicativo Rodando em Background 1}{print-bkg1}{Autoria Própria}{}
\diagramaRetrato{print-bkg2.png}{0.8}{Aplicativo Rodando em Background 2}{print-bkg2}{Autoria Própria}{}

\include{./texto/especificacoes/requisitos-funcionais}
\input{./texto/especificacoes/requisitos-nao-funcionais}
\include{./texto/especificacoes/avaliacoes}