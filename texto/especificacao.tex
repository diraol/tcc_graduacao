\chapter{Especificação}\label{chp:Especificação}
O projeto foi desenvolvido para dispositivos móveis utilizando \textit{tecnologia de desenvolvimento híbrida}, visando facilitar o desenvolvimento e o deploy em diversas plataformas móveis. Neste capítulo descreveremos a especificação técnica do \textit{backend} e do aplicativo mobile do projeto.

\section{Aplicações do \textit{Backend}}\label{sec:spec-backend}
Como solução de \textit{backend} foi utilizado o \textit{framework} \gls{django}, que utiliza a linguagem de programação \textbf{Python} e é organizado segundo a \textit{design pattern} \gls{mvt}, conforme pode ser visto nas Figuras \ref{fig:arqMVT} e \ref{fig:arqDjango}.%
%
\diagramaRetrato{arquitetura-app-django.png}{0.8}{Arquitetura MVT de um APP do framework Django}{arqMVT}{Jeff Croft em {\footnotesize\url{http://www.flickr.com/photos/jcroft/432038560/sizes/o/in/photostream/}}}{}%
%
\diagramaRetrato{django-arq2.eps}{1.1}{Arquitetura do framework Django}{arqDjango}{Autoria própria}{baseado em {\footnotesize\url{http://www.slideshare.net/AbhijeetShekhar1/django-39439148}}}

A estrutura de projeto do \textit{framework} é pensada de forma modular, na qual a aplicação é composta por ''\textit{apps}'' independentes que realizam funções específicas e são conectados no projeto, conforme pode ser visto na Figura \ref{fig:multiApps}.%
%
\diagramaRetrato{django-multi-apps.jpg}{0.45}{Arquitetura multi-aplicativos do Django}{multiApps}{Ian Ward em {\footnotesize\url{http://excess.org/article/2007/06/oclug-django-site/}}}{}

Considerando tal arquitetura, foram desenvolvidos os 3 módulos principais já descritos anteriormente, na Seção \ref{sec:Escopo} (\textbf{Avaliação}, \textbf{Game} e \textbf{GPS social}). Além destes, também foi necessária a criação de um módulo adicional (\textit{utils}) com a finalidade de suprir algumas integrações entre os \textit{apps} sem impactar no isolamento entre eles. A função principal deste módulo foi a de criar a \gls{api} \gls{rest} do projeto

A \gls{api} \gls{rest} foi implementada utilizando-se o pacote \gls{drf}\footnote{\url{http://www.django-rest-framework.org}}. Com o uso do \gls{drf} foi necessário desenvolver algumas classes serializadoras vinculadas aos modelos de dados que seriam expostos (\textit{models}), em seguida criar as respectivas \textit{views} e criar um \textit{Router} com as urls que seriam expostas. Sequer foi necessária a criação de templates, visto que o pacote já fornece um template padrão. O módulo expõe os dados no formato \gls{json}, para além da apresentação na interface web, sem que seja necessário qualquer desenvolvimento ou configuração.

Foi utilizado também o pacote \gls{psa} para permitir a autenticação dos usuários com seus logins de redes sociais. Neste primeiro momento foram disponibilizados os logins via \textit{Facebook}\footnote{\url{https://developers.facebook.com/docs/facebook-login/v2.2}} e via \textit{Google Social Login}\footnote{\url{https://developers.google.com/+/web/signin/}}, ambos utilizando o protocolo de autenticação OAuth 2.0\footnote{\url{http://oauth.net/2/}}. Neste primeiro momento não foi utilizada a rede social \textit{Twitter} pois a mesma não disponibiliza o email do usuário ao realizar o login, o que impede que possamos vincular a conta da rede social com usuários já cadastrados.

Como o aplicativo lida com dados georreferenciados, para \gls{sgbd} foi escolhido o \textbf{PostgreSQL} com a extensão \textbf{PostGis}, visto que esta é a solução mais amplamente utilizada no mercado e com melhor suporte, além de ser a recomendada pelos desenvolvedores do \gls{django}, de sua extensão ``geo'' e da biblioteca python (\textit{gdal (Geospatial Data Abstraction Library)}). A solução escolhida permite inclusive realizar consultas utilizando critérios de geolocalização como, por exemplo, ``Selecionar todos os registros cuja localização se encontra num raio de X metros do ponto Y'', o que é fundamental para a criação do módulo \textbf{mapa}.

O framework \gls{django} por si só não é um webserver - ele apenas possui um microserver para fins de teste e desenvolvimento; então faz-se necessário utilizar um webserver. No presente projeto optou-se pelo \gls{nginx}, o servidor web que tem crescido no ritmo mais acelerado dos que possuem pelo menos 1\% do mercado. Seu ritmo anual médio de crescimento de 2010 a 2014 43\%, e hoje ele já ocupa a segunda colocação como servidor mais utilizado na internet com 22,6\% do mercado, atrás apenas do Apache, que tem 59\% do mercado mas que tem perdido, em média, 3,71\% de \textit{market share} ao ano, conforme pode ser observado na Figura \ref{fig:nginxmarkershare}.

\diagramaRetrato{market_share_webservers.png}{0.55}{\textit{Market Share} de servidores web}{nginxmarkershare}{W3Techs - Web Technology Surveys {\footnotesize\url{http://w3techs.com/technologies/history_overview/web_server/ms/y}}}{}

Além dessa grande exposição, e de possuir uma boa documentação\footnote{\url{http://nginx.org/en/docs/}}, outra vantagem é que ele consegue cumprir a função de webserver, proxy reverso e também possui recursos de \textit{load balance}, tornado-o uma ótima alternativa em termos de escalabilidade.

O \gls{nginx} por si só não consegue "fornecer" diretamente a aplicação django, para tanto é preciso ainda mais um elemento, que é o servidor de aplicações. Para tanto, um dos que apresenta melhor desempenho nos dias de hoje para servir projetos que utilizam a linguagem de programação Python é o \gls{uwsgi}\footnote{\url{https://ivan-site.com/2012/09/benchmark-uwsgi-vs-gunicorn-for-async-workers/}}$^,$\footnote{\url{http://blog.kgriffs.com/2012/12/18/uwsgi-vs-gunicorn-vs-node-benchmarks.html}}$^,$\footnote{\url{http://www.peterbe.com/plog/fcgi-vs-gunicorn-vs-uwsgi}}. Dessa maneira, optamos pelo \gls{uwsgi} como servidor de aplicação trabalhando em conjunto com o \gls{nginx} como servidor web.

Fica como sugestão para o futuro do projeto a utilização do servidor de cache \textit{varnish}\footnote{\url{https://www.varnish-cache.org/}}, conforme recomendado pela equipe do hosting DigitalOcean\footnote{\url{https://www.digitalocean.com/community/tutorials/how-to-scale-django-beyond-the-basics}}, para conseguir escalar o projeto sem precisar necessariamente de mais recursos de máquina.

\section{Estrutura implementada da Aplicação}\label{sec:estrutura-app}
Nesta seção iremos descrever a implementação realizada de cada um dos \textit{apps}, assim como do projeto \gls{django} que integra os \textit{apps}. Por motivos organizacionais optou-se por descrever cada uma das camadas do \textit{design pattern} para todos os aplicativos simultâneamente ao invés de descrever cada aplicativo individualmente.

\subsection{Camada de Acesso a Dados (\textit{model})}\label{subsec:camada-model}
Inicialmente foi planejada uma camada de modelo de dados conforme o Diagrama Entidade-Relacionamento exposto na Figura \ref{fig:DiagER}.
\section{Diagrama Entidade Relacionamento}
    \diagramaRetrato{diagramas_er_bds.eps}{1.2}{Diagrama Entidade Relacionamento}{DiagER}{Autoria Própria}{}

\input{./texto/especificacoes/diagrama-de-classes}


\section{Aplicativo Mobile}\label{sec:spec-appmobile}

Já para o desenvolvimento Para o \textit{frontend} do projeto será utilizado \textbf{HTML5}, \textbf{CSS3} e \textbf{JavaScript}, além de algumas bibliotecas auxiliares como \textbf{Twitter Bootstrap} (versão 3).




\include{./texto/especificacoes/requisitos}
\input{./texto/especificacoes/requisitos-nao-funcionais}
\input{./texto/especificacoes/casos-de-uso}
\section{Tabelas Resumo de Requisitos e Casos de Uso}
\subsection{Tabela de Requisitos Funcionais}\label{subsec:tabResReqF}
   \begin{table}[H]
        \centering
        \caption{Requisitos funcionais}
        \label{tab:reqFunc}
        \PrintRequisitosFunc
    \end{table}
    

\subsection{Tabela de Requisitos Não Funcionais}\label{subsec:tabResReqNF}
   \begin{table}[H]
        \centering
        \caption{Requisitos não funcionais}
        \label{tab:reqNFunc}
        \PrintRequisitosNFunc
    \end{table}

\include{./texto/especificacoes/avaliacoes}