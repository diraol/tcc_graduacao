\chapter{Especificação}\label{chp:Especificação}
O projeto foi elaborado de maneira que a interação do usuário ocorra por meio de um aplicativo móvel. Como haverá troca de informações entre os usuários, e também armazenamento de dados advindos dos mesmos, será necessário desenvolver, além do aplicativo móvel, também um servidor de infraestrutura de dados (\textit{backend}).

Neste capítulo serão descritas as especificações e a implementação tanto do aplicativo móvel quanto do servidor de \textit{backend}.

\section{Tecnologias do \textit{Backend}}\label{sec:spec-backend}
Como solução de \textit{backend} foi utilizado o \textit{framework} \gls{django}, que utiliza a linguagem de programação \textbf{Python} e é organizado segundo a \gls{dp} \gls{mvt}, conforme pode ser visto nas Figuras \ref{fig:arqMVT} e \ref{fig:arqDjango}.%
%
\diagramaRetrato{arquitetura-app-django.png}{0.9}{Arquitetura MVT de um APP do framework Django}{arqMVT}{Jeff Croft em {\footnotesize\url{http://www.flickr.com/photos/jcroft/432038560/sizes/o/in/photostream/}} - Acesso em 01/08/2014}{} %TODO TRADUZIR
%
\diagramaRetrato{django-arq2.eps}{1.1}{Arquitetura do framework Django}{arqDjango}{Abhijeet Shekhar em {\footnotesize\url{http://www.slideshare.net/AbhijeetShekhar1/django-39439148}} - Acesso em 01/08/2014}{}

A estrutura de projeto do \textit{framework} é pensada de forma modular, na qual a aplicação é composta por ''\textit{apps}'' independentes que realizam funções específicas e são conectados no projeto, conforme pode ser visto na Figura \ref{fig:multiApps}.%
%
\diagramaRetrato{django-multi-apps.jpg}{0.42}{Arquitetura multi-aplicativos do Django}{multiApps}{Ian Ward em {\footnotesize\url{http://excess.org/article/2007/06/oclug-django-site/}} - Acesso em 01/08/2014}{} %TODO TRADUZIR

Considerando tal arquitetura, foram desenvolvidos os três módulos principais já descritos anteriormente, na Seção \ref{sec:Escopo} (\textbf{Avaliação}, \textbf{Game} e \textbf{GPS social}). Além destes, também foi necessária a criação de um módulo adicional (\textit{utils}) com a finalidade de suprir algumas integrações entre os \textit{apps} sem impactar no isolamento\footnote{Os diversos \textit{apps} de um projeto \gls{django} são construídos para serem completamente independentes entre si, ou seja, são aplicações independentes que trabalham de forma isolada uma das outras, permitindo que sejam utilizadas e reutilizadas em diversos contextos.} entre eles. A função principal deste módulo foi a de definir a \gls{api} \gls{rest} do projeto

A \gls{api} \gls{rest} foi implementada utilizando-se o pacote \gls{drf}%
\footnote{\textit{Django Rest Framework} \url{http://www.django-rest-framework.org} - Acesso em 01/09/2014}. Com o uso do \gls{drf} %
foi necessário desenvolver classes serializadoras%
\footnote{O papel básico de um serializador é transformar um Objeto numa sequência de caracteres, uma \textit{string}, que passa a ser a representação textual do objeto, contendo seus atributos.}%
, cada uma vinculada a um dos modelos de dados a ser exposto (\textit{models}).
Em seguida foi preciso criar as respectivas \textit{views} para os serializadores e um Roteador%
\footnote{Um Roteador nada mais é que um conjunto de regras que verificam um endereço, comparando-o com os endereços cadastrados, e caso o endereço se enquadre em alguma das regras os dados da requisição são repassados a alguma função estipulada na determinada regra.}
(\textit{Router}) com as urls que seriam expostas. Sequer foi necessária a criação de templates, visto que o pacote já fornece um template padrão. O módulo expõe os dados no formato \gls{json}, para além da apresentação na interface web, sem que seja necessário qualquer desenvolvimento ou configuração.

Foi utilizado também o pacote \gls{psa} para permitir a autenticação dos usuários com seus logins de redes sociais. Neste primeiro momento foram disponibilizados os logins via \textit{Facebook}%
\footnote{\url{https://developers.facebook.com/docs/facebook-login/v2.2} - Acesso em 20/08/2014}
e via \textit{Google Social Login}%
\footnote{\url{https://developers.google.com/+/web/signin/} - Acesso em 20/08/2014}, 
ambos utilizando o protocolo de autenticação OAuth 2.0%
\footnote{\url{http://oauth.net/2/} - Acesso em 18/08/2014}.
Neste primeiro momento não foi utilizada a rede social \textit{Twitter} pois a mesma não disponibiliza o e-mail do usuário ao realizar o login, o que impede que possamos vincular a conta da rede social com usuários já cadastrados.

Como o aplicativo lida com dados georreferenciados, para \gls{sgbd} foi escolhido o \textbf{PostgreSQL} com a extensão \textbf{PostGis}, visto que esta é a solução recomendada pelos desenvolvedores do \gls{django}%
\footnote{``PostGIS é recomendado, pois é a solução de código aberto para bases de dados espaciais mais madura e cheia de recursos'' conforme nota em: {\url{https://docs.djangoproject.com/en/1.7/ref/contrib/gis/install/\#spatial-database}} - Acesso em: 25/08/2014},
de sua extensão ``geo'' e da biblioteca python \textit{gdal (Geospatial Data Abstraction Library)}. A solução escolhida permite realizar consultas utilizando critérios de geolocalização como, por exemplo, ``Selecionar todos os registros cuja localização se encontra num raio de X metros do ponto Y'', o que é fundamental para a criação do módulo \textbf{mapa}.

O \textit{framework} \gls{django} por si só não é um servidor web - ele apenas possui um micro-servidor para fins de teste e desenvolvimento%
\footnote{O servidor \textit{lightweight} incluso no \textit{framework} \gls{django} foi desenvolvido apenas com o objetivo de testes de desenvolvimento. Conforme está exposto na documentação oficial: ``NÃO UTILIZE ESTE SERVIDOR EM CONFIGURAÇÃO DE PRODUÇÃO. Ele não passou por auditorias de segurança e testes de performance'' - {\url{https://docs.djangoproject.com/en/1.7/ref/django-admin/\#runserver-port-or-address-port}} - Acesso em 28/08/2014}%
; então faz-se necessário utilizar um servidor web. No presente projeto optou-se pelo \gls{nginx}, o servidor web que tem crescido no ritmo mais acelerado dos que possuem pelo menos 1\% do mercado. Seu ritmo anual médio de crescimento de 2010 a 2014 foi de 43\%, e hoje ele já ocupa a segunda colocação como servidor mais utilizado na internet com 22,6\% do mercado, atrás apenas do Apache, que tem 59\% do mercado mas que tem perdido, em média, 3,71\% de \textit{market share} ao ano, conforme pode ser observado na Figura \ref{fig:nginxmarkershare}.

\diagramaRetrato{market_share_webservers.png}{0.55}{\textit{Market Share} de servidores web}{nginxmarkershare}{W3Techs - Web Technology Surveys {\footnotesize\url{http://w3techs.com/technologies/history_overview/web_server/ms/y}} - Acesso em 01/09/2014}{}
\clearpage
Além dessa grande exposição, e de possuir uma boa documentação%
\footnote{Documentação do NGINX - \url{http://nginx.org/en/docs/} - Acesso em 01/09/2014}, outra vantagem é que ele consegue cumprir as funções de servidor web, proxy reverso%
\footnote{A função de proxy reverso pode ser entendida como a função de um intermediário num processo qualquer de comunicação. O Usuário (ou cliente) faz uma requisição a um endereço web, assumindo que estará se comunicando diretamente com o servidor web que processa a requisição. Entretando, ele (cliente) está se comunicando com o servidor de proxy, que poderá ou não repassar a requisição a um servidor que irá efeticamente processar esta requisição. Caso tenha ocorrido o repasse, a resposta é devolvida ao proxy reverso que a encaminha ao usuário. Uma das grandes vantagens deste modelo é a possibilidade de implementação de arquiteturas de balanceamento entre diversos servidores de processamento. Outra grande vantagem é que, caso a requisição já tenha sido realizada anteriormente, o próprio servidor de proxy reverso pode atuar como um servidor de \textit{cache}, respondendo com a mesma resposta anterior, poupando assim processamento e carga do servidor de processamento.},
além de outros recursos, tornado-o uma ótima alternativa em termos de escalabilidade.

Porém, o \gls{nginx} não consegue ``fornecer'' (processar as requisições e executar os códigos do \textit{framework}) diretamente a aplicação \gls{django}, para tanto é preciso ainda mais um elemento, que é o servidor de aplicações. Para esta função, um dos que apresenta melhor desempenho nos dias de hoje com relação a projetos que utilizam a linguagem de programação Python é o \gls{uwsgi}%
\footnote{\textit{uWSGI vs Gunicorn para requisições assíncronas} \url{https://ivan-site.com/2012/09/benchmark-uwsgi-vs-gunicorn-for-async-workers/} - Acesso em 01/09/2014}$^,$%
\footnote{\textit{uWSGI vs Gunicorn vs node} \url{http://blog.kgriffs.com/2012/12/18/uwsgi-vs-gunicorn-vs-node-benchmarks.html} - Acesso em 01/09/2014}$^,$%
\footnote{\textit{FCGI vs Gunicorn vs uWSGI} \url{http://www.peterbe.com/plog/fcgi-vs-gunicorn-vs-uwsgi} - Acesso em 01/09/2014}.
Dessa maneira, optamos pelo \gls{uwsgi} como servidor de aplicação trabalhando em conjunto com o \gls{nginx} como servidor web.

Por fim, fica como sugestão para o futuro do projeto a utilização do servidor de cache \textit{varnish}%
\footnote{Varnish Servidor de Cache - \url{https://www.varnish-cache.org/} - Acesso em 20/11/2014}, conforme recomendado pela equipe do hosting DigitalOcean%
\footnote{``Como escalar o Django além do básico'' - \url{https://www.digitalocean.com/community/tutorials/how-to-scale-django-beyond-the-basics} - Acesso em 20/11/2014}, para conseguir escalar o projeto sem precisar necessariamente de mais recursos de máquina.

\section{Modelagem de Dados}\label{sec:diagrama-er}
\diagramaRetrato{diagramas_er_bds.eps}{1.2}{Diagrama Entidade Relacionamento}{DiagER}{Autoria Própria}{}
Na Figura \ref{fig:DiagER} encontra-se a modelagem de dados realizada inicialmente no projeto. Esta modelagem não leva em consideração as especificidades do \textit{framework} utilizado, e eventuais diferenças serão expostas na descrição dos \textit{apps}.

Esta modelagem leva em conta cinco grandes grupos de entidades:
    \begin{enumerate*}[label=\itshape\alph*\upshape)]
        \item Ônibus;
        \item Avaliação;
        \item Geolocalização;
        \item Gerais; e
        \item Game.
    \end{enumerate*}.

As entidades do grupo \textbf{ônibus} são as que definem um determinado veículo a ser avaliado pelo usuário do serviço de transporte. Ela conta com duas classes principais, \textit{onibus} e \textit{linhas\_de\_onibus}. A classe relativa à linha de ônibus representa uma determinada linha de ônibus, incluindo trajeto de ida e de volta. Já a classe \textit{onibus} conterá o cadastro de cada veículo e a qual linha este veículo está associado. O atributo \textit{numero\_onibus} deve ser único e é o que será representado no \gls{qrcode} que será digitalizado pelo usuário do aplicativo.

As entidades do grupo \textbf{avaliação} são as que compõe o modelo do módulo de mesmo nome. Nele temos \textit{aval\_tipo\_resposta}, classe que define os tipos possíveis de respostas a serem dadas pelos usuários do aplicativo. Seu objetivo é uniformizar as respostas que as perguntas podem receber. Temos também a classe \textit{aval\_pergunta}, na qual são definidas as perguntas que serão apresentadas aos usuários. A primeira delas, de id=0, deverá ser a pergunta ``geral''. As demais perguntas podem ser adicionadas livremente e ativadas ou inativadas. Por fim, no grupo ainda existe a classe \textit{respostas}. que irá armazenar as respostas enviadas pelos usuários.

Outro grupo que temos é o \textbf{gerais}, que contém informações dos usuários (cadastro, login e permissões).

Temos também o grupo \textbf{geolocalização}, que contém as tabelas que armazenam o registro de localização dos usuários. Para melhorar o desempenho, optou-se por salvar a localização do usuário em duas tabelas distintas. Uma delas, \textit{last\_geolocation}, armazena a última localização de cada usuário. Já a tabela \textit{geolocation\_history} armazenará todas as localizações de cada usuário. Essa opção de duas tabelas distintas foi feita para melhorar o desempenho do banco na geração do mapa do módulo \textbf{GPS Social}, que só precisará buscar informações nesta única tabela com número de registros igual ao número de usuários, e não na tabela que contém todo o histórico de localização de cada usuário. Já esta última tabela poderá ser utilizada, no futuro, para geração de índices e indicadores.

Por último temos o grupo \textbf{game}, que representa as entidades responsáveis pelo armazenamento dos dados do jogo presente no aplicativo. Nele temos algumas entidades ``fundamentais'', ou básicas. Começamos pela classe \textit{game\_tipos\_moedas}, que contém a listagem dos tipos de moedas disponíveis no jogo. Em seguida passamos pela classe \textit{game\_base\_onibus}, que contém dos ônibus disponíveis para serem comprados pelos usuários. A última classe ``básica'' é a \textit{game\_base\_rendimento\_onibus}, que contém o rendimento de cada tipo de ônibus em termos de quantidades das moedas existentes no jogo. Temos ainda duas classes auxiliares, \textit{game\_aux\_tipo\_onibus} e \textit{game\_aux\_marca\_onibus}, que servem de caracterização dos ônibus disponíveis no sistema. Por fim, temos duas classes ligadas aos jogadores e mutáveis ao longo do tempo: \textit{rel\_usuario\_moedas}, que armazena a quantidade de moedas que um determinado usuário possui e \textit{frota\_do\_usuario}, que mantém a informação da frota de ônibus de cada usuário.

\clearpage
\section{Implementação}\label{sec:estrutura-app}
Nesta seção será descrita a rotina de implementação da infraestrutura de \textit{backend} como um todo e a implementação de cada um dos \textit{apps}, assim como do projeto \gls{django} que integra os \textit{apps}. Cada \textit{app} será descrito considerando o \gls{dp} \gls{mvt}.

A implementação completa dos \textit{models}, das \textit{views}, \textit{serializers} e \textit{urls} pode ser encontrada no Anexo \ref{anexo:sources} ou no repositório oficial do projeto\footnote{Repositório Oficial do Projeto: \url{http://github.com/diraol/trilhasp} - Acessado em 15/12/2014}

Com o objetivo de facilitar colaborações e outros trabalhos futuros, o código fonte do projeto utiliza como idioma padrão o inglês, desta forma, os \textit{apps}, módulos, as classes e os atributos utilizarão termos neste idioma que representam o que nesta monografia estiver descrito em português.

\subsection{Setup Inicial}
Para o \textit{setup} inicial do servidor foi criado um \textit{shell script} que realiza toda a instalação. Ele foi desenvolvido e testado para o sistema operacional \textbf{Debian Jessie (8.0)}.

Este \textit{setup} inicial contempla a instalação do \gls{django}, do \gls{sgbd} \textbf{PostgreSQL} (v9.4), com sua extensão de dados espaciais \textbf{PostGis} (v2.1), além dos pacotes necessários para a utilização do recurso de ambientes virtuais (\textit{Virtualenv}) do \textbf{Python}, o que facilita o encapsulamento e a manutenabilidade da aplicação num servidor. Iniciaremos pela listagem dos requisitos necessários para implantação de nosso ambiente.

Requisitos para a utilização de ambientes virtuais: %
\begin{enumerate*}[label=\itshape\alph*\upshape)] 
    \item \mbox{\textit{python-setuptools}};
    \item \mbox{\textit{python-pip}};
    \item \mbox{\textit{python-dev}}
\end{enumerate*}.

Requisitos para a base de dados espaciais e sua integração com o Python: %
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item\mbox{\textit{postgresql-9.4}};
    \item\mbox{\textit{postgresql-contrib-9.4}};
    \item\mbox{\textit{postgresql-9.4-postgis}};
    \item\mbox{\textit{postgresql-server-dev-9.4}};
    \item\mbox{\textit{libpq-dev}};
    \item\mbox{\textit{binutils}};
    \item\mbox{\textit{libproj-dev}};
    \item\mbox{\textit{gdal-bin}};
    \item\mbox{\textit{python-gdal}};
    \item\mbox{\textit{python-psycopg2}}
\end{enumerate*}.

Após instalados os pacotes, o \textit{script} irá realizar a criação de um usuário \textit{trilhasp} no PostgreSQL, na qual será requisitado ao usuário para inserir um \textit{password}, para que, em seguida, seja criada automaticamente a base de dados dentro do \gls{sgbd}, com codificação (\textit{encoding}) UTF-8, e sejam instaladas as extensões de georreferenciamento na base recém criada.

Em seguida, será instalado o pacote \textit{virtualenv} do \textbf{Python}, com o uso da ferramenta de gerenciamento de pacotes \textit{pip}, e é criado um novo ambiente virtual (numa pasta chamada \textbf{venv}), que é ativado e no qual são instalados os demais \textit{requirements} de Python, que ficam definidos no arquivo \textit{requirements.txt}.

Finalizando o \textit{setup} inicial do \gls{django}, o \textit{script} irá executar os comandos para criação das bases de dados, tomando como referência os modelos (\textit{models}) de todas as aplicações listadas nas configurações do \gls{django}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP AVALIAÇÃO                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Avaliação}
No código fonte do projeto este módulo foi chamado de \textit{evaluation}.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:eval-camada-model}
Neste \textit{app} foram criadas as classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{BusCompanies};
    \item \textit{BusLine};
    \item \textit{Buses};
    \item \textit{EVALAnswerModel};
    \item \textit{EVALQuestion}; e
    \item \textit{EVALAnswer}
\end{enumerate*}.
A classe \textit{BusCompanies} contém dados sobre as empresas de ônibus, a classe \textit{BusLine} contém informações sobre as linhas de ônibus, a classe \textit{Buses} possui informações de cadastro dos veículos, a classe \textit{EVALAnswerModel} contém os modelos de respostas possíveis de serem dados e que serão vinculados a uma pergunta da classe \textit{EVALQuestion}, que contém as questões que estarão disponíveis aos usuários e, por fim, a classe \textit{EVALAnswer}, que armazenará as respostas (avaliações) dos usuários.

Na Tabela \ref{tab:model-app-avaliacao} encontram-se os atributos de cada uma das classes, seus tipos e descrições:

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP Avaliação \label{tab:model-app-avaliacao}}    
  }{
    \begin{tabular}{|P{2.9cm}|P{3.2cm}|P{2.5cm}|P{5.4cm}|}
    \hline
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{2}{2.9cm}{BusCompanies} & company\_name & CharField & Nome da Empresa \\ \cline{2-4}
        & logo & ImageField & Logo da empresa \\ \hline
        \multirow{5}{2.9cm}{BusLine} & bus\_line\_code & CharField & Código da linha do ônibus \\ \cline{2-4}
        & going\_bus\_name & CharField & Nome do trajeto de ida \\ \cline{2-4}
        & return\_bus\_name & CharField & Nome do trajeto de volta \\ \cline{2-4}
        & active & BooleanField & Estado da linha (ativa ou inativa) \\ \cline{2-4}
        & company\_name & ForeignKey & Empresa responsável pela linha \\ \hline
        \multirow{3}{2.9cm}{Buses} & bus\_unique\_number & IntegerField & Número único de cada veículo \\ \cline{2-4}
        & bus\_line\_code & ForeignKey & Código da linha que este ônibus serve \\ \cline{2-4}
        & active & BooleanField & Estado da linha (Ativa ou inativa) \\ \hline
        \multirow{7}{2.9cm}{EVALAnswerModel} & answer & CharField & texto explicativo deste tipo de resposta \\ \cline{2-4}
        & upper\_limit\_text & CharField & Label do valor superior\\ \cline{2-4}
        & middle\_text & CharField & Label do valor central\\ \cline{2-4}
        & lower\_limit\_text & CharField & Label do valor inferior\\ \cline{2-4}
        & uppwer\_limit\_value & IntegerField & Valor do limite superior\\ \cline{2-4}
        & middle\_value & IntegerField & Valor central\\ \cline{2-4}
        & lower\_limit\_Value & IntegerField & Valor do limite inferior\\ \hline
        \multirow{3}{2.9cm}{EVALQuestion} & question & CharField & Texto da questão que será apresentado ao usuário\\ \cline{2-4}
        & answer & ForeignKey & Tipo da resposta para esta pergunta\\ \cline{2-4}
        & enabled & BooleanField & Estado da pergunta (ativa ou inativa)\\ \hline
        \multirow{7}{2.9cm}{EVALAnswer} & question & ForeignKey & Questão \\ \cline{2-4}
        & user & ForeignKey & Usuário respondente\\ \cline{2-4}
        & timestamp & DateTimeField & Data e horário da resposta\\ \cline{2-4}
        & answer\_value & IntegerField & Valor numérico da resposta\\ \cline{2-4}
        & answer\_text & CharField & Texto inserido pelo usuário\\ \cline{2-4}
        & bus\_unique\_number & ForeignKey & Número único do ônibus\\ \cline{2-4}
        & geolocation & PointField & Geolocalização do usuário no momento da resposta (ex.: \textit{POINT( lng lat )})\\
    \hline
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}
\clearpage
\subsubsection{Serializadores}
Para a criação da \gls{api} o \gls{drf} requer que o desenvolvedor crie um (ou mais) serializador(es) para cada classe que se deseja expor e, em seguida, que sejam criadas as views que utilizam esses serializadores. Assim, para este \textit{app} foram criados os seguintes serializadores: %
\begin{itemize}
    \item \textit{BusCompaniesSerializer};
    \item \textit{BusLineSerializer};
    \item \textit{BusesSerializer};
    \item \textit{EVALAnswerModelSerializer};
    \item \textit{EVALQuestionSerializer}; e
    \item \textit{EVALAnswerSerializer}.
\end{itemize}

Todos eles foram criados como extensões da classe \textit{serializers.HyperlinkedModelSerializer}%
\footnote{Classe \textit{HyperlinkedModelSerializer} - \url{http://www.django-rest-framework.org/api-guide/serializers/\#hyperlinkedmodelserializer} - Acesso em 15/09/2014}%
, o que faz com que a \gls{api} exposta faça o link entre objetos que são chave-estrangeira e o objeto que está sendo mostrado. Além disso, no serializador \textit{BusesSerializer}, que serializa a classe \textit{BusLine} foi definido como ``campo de busca'' (\textit{lookup\_field}), ou ``campo de referência'', o atributo ``\textit{bus\_line\_code}'', de forma que a busca pelos ônibus na API possa ser realizada pelo código da linha de ônibus, ao invés de um parâmetro de id arbitrário.

\subsubsection{Camada de lógica de negócio (\textit{views})}\label{subsubsec:eval-camada-view}
Esta camada irá expor os serializadores definidos anteriormente. As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{BusCompanyViewSet};
    \item \textit{BusLineViewSet};
    \item \textit{BusesViewSet};
    \item \textit{EVALAnswerModelViewSet};
    \item \textit{EVALQuestionViewSet}; e
    \item \textit{EVALAnswerViewSet}.
\end{itemize}

Estas classes foram definidas como extensões da classe ViewSet do \gls{drf}, o que já contempla automaticamente a criação de \textit{views} para lista de resultados e também para um resultado único em cada visão.

Na definição destas classes podemos especificar quais campos serão expostos na \gls{api}, as permissões de acesso, caso se deseje uma diferente da presente no arquivo de configurações do \gls{django}. Outra opção que pode ser configurada nesta etapa é a definição de qual será o campo (atributo) que será utilizado para buscas, caso deseje-se algum diferente do padrão (chave primária da classe).

Neste app apenas a classe \textit{BusLineViewSet} sofreu uma modificação para além do padrão. Nela foi definido o campo \textit{bus\_line\_code} como sendo o campo de busca dos objetos.

\subsubsection{Camada de Adminsitração}
O \gls{django} oferece por padrão um módulo de administração da aplicação, bastando ativá-lo no arquivo de configurações. Em seguida, para cada \textit{app} é necessário registrar quais são as classes (do modelo) que estarão disponíveis para administração, e, eventualmente, fazer alguma personalização na forma como os campos/atributos da classe são apresentados no navegador.

No caso deste \textit{app} todas as classes foram expostas e ainda adicionou-se uma configuração para que a informação georreferenciada fosse apresentada num \textit{widget}%
\footnote{Um \textit{widget} é um componente de interface gráfica de usuário. Um campo de texto é um \textit{widget} que apresenta informações no formato de texto. Podemos ainda ter \textit{widgets} do tipo \textit{range}, no qual o usuário escolhe um valor numérico num determinado intervalo, do tipo \textit{date}, no qual o usuário seleciona uma data, dentre outros.}
de mapa, ao invés de se apresentar uma coordenada apenas. Esta configuração encontra-se no arquivo \textit{admin.py} do \textit{app} e também está disponível no Anexo \ref{anexo:sources}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              APP GPSSocial                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP GPSSocial}
Agora veremos o \textit{app} responsável pelo mapa de GPS Social, chamado \textit{demandmap} na implementação do projeto.

\subsubsection{Camada de Acesso a Dados (\textit{model})}\label{subsubsec:gps-camada-model}
Neste \textit{app} foram criadas as seguintes classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{GEOHistoryPosition}; e
    \item \textit{GEOLastPosition}
\end{enumerate*}.
Conforme dito anteriormente, a classe \textit{GEOHistoryPosition} armazena o histórico de localizações de todos os usuários, enquanto a classe \textit{GEOLastPosition} armazena apenas a última localização de cada usuário. O motivo desta escolha é para que se possa manter todo registro de localização dos usuários para fins de estudos e pesquisas sobre o comportamento dos mesmos, sem comprometer o desempenho da aplicação, que utilizará apenas a última localização.

A seguir, na Tabela \ref{tab:model-app-gps-social}, são apresentados os atributos, seus tipos e descrições, para cada uma das classes:

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP GPSSocial \label{tab:model-app-gps-social}}    
  }{
    \begin{tabular}{|P{3.1cm}|P{3cm}|P{2.5cm}|P{5.4cm}|}
    \hline
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{3}{3.1cm}{GEOPositionHistory} & user & ForeignKey & Usuário \\ \cline{2-4}
        & geolocation & PointField & Localização do Usuário\\ \cline{2-4}
        & timestamp & DateTimeFIeld & Horário do registro\\ \hline
        \multirow{3}{3.1cm}{GEOLastPosition} & user & ForeignKey & Usuário \\ \cline{2-4}
        & geolocation & PointField & Última localização do Usuário\\ \cline{2-4}
        & timestamp & DateTimeFIeld & Horário do registro\\
    \hline
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores:
\begin{itemize}
    \item \textit{GEOLastPositionSerializer};
    \item \textit{GEOLastAnonPositionSerializer}; e
    \item \textit{GEOHistoryPositionSerializer}.
\end{itemize}

Os serializadores \textit{GEOLastPositionSerializer} e \textit{GEOLastAnonPositionSerializer} são extensões da classe \mbox{\textit{GeoFeatureModelSerializer}}%
\footnote{Classe \textit{GeoFeatureModelSerializer} do módulo \textit{DjangoRestFramework-gis} - \url{https://pypi.python.org/pypi/djangorestframework-gis/0.2} - Acesso em 15/09/2014},
e o serializador \mbox{\textit{GEOHistoryPositionSerializer}} é uma extensão da classe \mbox{\textit{HyperlinkedModelSerializer}}.

Aqui nota-se que há mais serializadores que classes no modelo. Isto ocorreu pois foi criado um serializador (\textit{GEOLastAnonPositionSerializer}) para oferecer as informações dos usuários de forma anonimizada, garantindo a privacidade dos usuários. Esta anonimização foi feita escolhendo-se os campos que seriam apresentados pelo serializador, sendo que o campo \textit{user} não foi adicionado à lista. Além disso, nestes serializadores também foi necessário identificar o campo \textit{geolocation} como sendo um campo do tipo \textit{geo}, para que o serializador saiba a melhor forma de serializar estes dados.

Outras duas mudanças realizadas nestes serializadores não anônimos foi a definição de que o campo de busca seria o \textit{username}.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Aqui definem-se as \textit{views} criadas que servem para expor as classes serializadoras: %
\begin{itemize}
    \item \textit{GEOLastPositionViewSet};
    \item \textit{LastUserPosition};
    \item \textit{LastUsersAtPosition}; e
    \item \textit{GEOHistoryPositionViewSet}.
\end{itemize}

Aqui novamente percebemos quatro classes. A classe \textit{GEOLastPositionViewSet} retorna todos os resultados da última localização de cada usuário%
\footnote{Na classe \textit{GEOLastPositionViewSet} ainda é necessário definir o o horário para que se filtre os resultados, para que não se tenha resultados muito desatualizados. Este filtro ocorrerá no próprio \textit{queryset} da classe.}, sendo que se o usuário que requisitou a informação foi um administrador, os objetos retornados conterão o campo com o nome do usuário de cada registro, e se não for administrador não será retornado o campo com a informação de qual usuário é referente a cada registro.

O campo \textit{GEOHistoryPositionViewSet} não apresenta qualquer configuração especial. Já a classe \textit{LastUsersAtPosition} foi criada para retornar os registros (anonimizados sem o campo de usuário) ao redor de uma determinada posição que tenham sido atualizados na última hora%
\footnote{Optou-se pela última hora apenas como exemplo, este valor pode ser ajustado, mas ainda está \textit{hardcoded}, o ideal é que fosse um dos parâmetros da requisição},
enquanto a classe \textit{LastUserPosition} retorna a última localização de um determinado usuário, de acordo com seu \textit{username}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                 APP Game                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Game}

\subsubsection{Camada de Acesso a Dados (\textit{model})}
Neste app foram criadas as seguintes classes:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{GameCoinModel};
    \item \textit{GameFinance};
    \item \textit{BusBrand};
    \item \textit{GameBusModel};
    \item \textit{GameBusAvailability}; e
    \item \textit{GamePersonalBusFleet}
\end{enumerate*}.
A Classe \textit{GameCoinModel} representa os tipos existentes de moedas no jogo, a classe \textit{GameFinance} representa as finanças dos usuários - quantas moedas de cada tipo o usuário possui; a classe \textit{BusBrand} contém as marcas de ônibus existentes. A classe \textit{GameBusModel} contém os modelos de ônibus disponíveis para serem comprados, enquanto a \textit{GameBusAvailability} contém a quantidade de cada um disponível para compra pelos usuários. Por fim, a classe \textit{GamePersonalBusFleet} contém quantos ônibus de cada tipo cada usuário possui, mantendo a informação da frota de cada usuário.

Na tabela \ref{tab:model-app-game} encontram-se os atributos de cada uma das classes, seus tipos e descrições.

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{\textit{Model} do APP Game \label{tab:model-app-game}}    
  }{
    \begin{tabular}{|P{3.5cm}|P{2.6cm}|P{2.4cm}|P{5.4cm}|}
    \hline
        \textbf{Classe} & \textbf{Atributo} & \textbf{Tipo do atributo} & \textbf{Descrição do atributo} \\
    \hline \hline
        \multirow{3}{3.5cm}{GameCoindModel} & name & CharField & Nome descritivo da moeda \\ \cline{2-4}
            & value & IntegerField & Valor (inteiro) da moeda\\ \cline{2-4}
            & enabled & BooleanField & Se a moeda está ativa ou inativa\\ \hline
        \multirow{3}{3.5cm}{GameFinance} & user & ForeignKey & Usuário \\ \cline{2-4}
            & coin\_model & ForeignKey & Modelo da moeda\\ \cline{2-4}
            & amount & IntegerField & Quantidade de moedas que o usuário possui\\ \hline
        \multirow{4}{3.5cm}{BusBrand} & label & CharField & Nome curto da empresa\\ \cline{2-4}
            & name & CharField & Nome completo da empresa\\ \cline{2-4}
            & logo & ImageField & Logotipo da marca\\ \cline{2-4}
            & enabled & BooleanField & Se o registro está ativo ou inativo\\ \hline
        \multirow{4}{3.5cm}{GameBusModel} & name & CharField & Nome do modelo\\ \cline{2-4}
            & bus\_brand & ForeignKey & Marca da empresa\\ \cline{2-4}
            & efficiency & IntegerField & Rendimento por hora do modelo\\ \cline{2-4}
            & price & IntegerField & Preço do modelo de ônibus\\ \hline
        \multirow{2}{3.5cm}{GameBusAvailability} & bus\_model & ForeignKey & Modelo do ônibus\\ \cline{2-4}
            & available\_buses & IntegerField & Quantidade do modelo disponível para venda\\ \hline
        \multirow{4}{3.5cm}{GamePersonalBusFleet} & user & ForeignKey & Usuário\\ \cline{2-4}
            & bus\_model & ForeignKey & Modelo do ônibus\\ \cline{2-4}
            & amount & IntegerField & Quantidade de ônibus daquele modelo que o usuário possui\\ \cline{2-4}
            & last\_payment & DateTimeField & Quando foi realizado o último ``pagamento'' ao usuário, referente a este tipo de ônibus\\
    \hline
    \end{tabular}%
  }{%
    \fonte{Produzido pelo autor}
  }
\end{table}

\subsubsection{Serializadores}
Para este \textit{app} foram criados os seguintes serializadores:%
\begin{itemize}
    \item \textit{GameCoinModelSerializaer};
    \item \textit{GameBusBrandSerializer};
    \item \textit{GameBusModelSerializer};
    \item \textit{GameBusAvailabilitySerializer};
    \item \textit{GameFinanceSerializer}; e
    \item \textit{GamePersonalBusFleetSerializer}.
\end{itemize}

Até o presente momento a única modificação necessária dos serializadores se deu nas classes \textit{GameFinanceSerializer} e \textit{GamePersonalBusFleetSerializer}, de forma que o atributo \textit{user} fosse utilizado como campo de busca de registros.

\subsubsection{Camada de lógica de negócio (\textit{views})}
As \textit{views} criadas foram: %
\begin{itemize}
    \item \textit{GameCoinModelViewSet};
    \item \textit{GameBusBrandViewSet};
    \item \textit{GameBusModelViewSet};
    \item \textit{GameBusAvailabilityViewSet};
    \item \textit{GamePersonalBusFleetViewSet}; e
    \item \textit{GameFinanceViewSet}.
\end{itemize}

Como as classes \textit{GamePersonalBusFleetViewSet} e \textit{GameFinanceViewSet} retornam apenas os registros referentes ao usuário que está realizando a busca - portanto este deve estar autenticado.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                APP Utils                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{APP Utils}
Este é o módulo que foi criado com o objetivo de unir os demais módulos do projeto.

\subsubsection{Funções auxiliares}
No arquivo \textit{util.py} foi criada uma classe adicional, baseada na classe padrão de permissões do módulo \gls{drf}, para que apenas usuários com permissões administrativas possam acessar informações pessoais, ou o próprio usuário. O nome desta classe é \textit{IsStaffOrTargetUser}, e ela foi utilizada nas \textit{views} anteriormente descritas.

Outras ``funções'' auxiliares que possam vir a ser necessárias e não sejam restritas a um módulo específico devem ser adicionadas neste arquivo.

\subsection{Serializadores}
Aqui foi criado o serializador para a classe padrão do \gls{django} referente aos usuários do sistema. Esta classe serializadora foi nominada de \textit{UserSerializer}. Ela possui uma configuração para definir o campo de senha (\textit{password}) como somente leitura, de forma que a informação da senha nunca seja enviada ao \textit{frontend} ou via \gls{api}. Outra modificação realizada nesta classe foi a criação de uma função (\textit{restore\_object}) para salvar a senha (no caso de alteração) utilizando a função padrão \textit{set\_password}, evitando assim que a senha seja salva em texto plano.

\subsubsection{Camada de lógica de negócio (\textit{views})}
Nesta camada foi criada a view (\textit{UserView}) para o serializador \textit{UserSerializer}. Nesta foi definido que o campo de busca para encontrar registros seria o nome de usuário (\textit{username}), além da permissão para administradores e para o próprio usuário dono do registro.

\subsection{Camada de Template}
Assim como em todos os outros módulos, nenhuma alteração foi realizada em termos de templates, visto que todas as páginas irão utilizar o template default do módulo \gls{drf}.

\subsection{URLs}\label{subsec:util-urls}
Aqui estão descritas as configurações relativas aos endereços (\textit{endpoints}\footnote{\textit{endpoint} é o termo utilizado para designar um endereço válido de uma \gls{api} que irá retornar algum dado}) aos quais a \gls{api} irá responder.
A maioria destes endereços foi definida utilizando a classe \textit{router} do próprio \textit{framework}, que se responsabiliza por criar todas as urls necessárias para cada \textit{view} registrada no \textit{router}, segundo um endereço inicial. Como alguns endereços foram criados fora do padrão básico do \textit{framework}, estes foram definidos seguindo o padrão de endereçamento do próprio \gls{django}.

Para se registrar um endereço no \textit{router}, a sintaxe é:
\begin{lstlisting}[language=Python,caption={Sintaxe padrão para registro de endereço no \textit{router}}]
router.register(r'user', UserView)
\end{lstlisting}
No exemplo acima, a view UserView será acessada ao se realizar uma requisição no \textit{endpoint} \textbf{user}. No caso do projeto, tomando a url base como sendo \textit{http://api.trilhasp.datapublika.com/v1/}, o \textit{endpoint} para acessar a view \textit{UserView} será \textit{http://api.trilhasp.datapublika.com/v1/user}, e este retornará todos os usuários cadastrados no sistema. O \textit{router} irá criar ainda uma série de outros endpoints baseados neste que foi definido, como, por exemplo, 
\textit{http://api.trilhasp.datapublika.com/v1/user/<username>}, que irá retornar as informação do usuário \textit{username}.

Os \textit{endpoints} que precisaram ser definidas fora do \textit{router}, seguindo o padrão do \gls{django}, foram as seguintes:
\begin{lstlisting}[language=Python,caption={EndPoints definidos manualmente}]
    url(r'^evaluation/bus/line/(?P<bus_line_code>[0-9A-Za-z--]+)/', BusLineViewSet.as_view(), name='bus-line'),
    
    url(r'^position/last/user/(?P<user>[^/.]+)/$', LastUserPosition.as_view(), name='lastlocation-detail'),
    
    url(r'^position/last/users/(?P<lon>(-?\d+\.\d+))_(?P<lat>(-?\d+\.\d+))/$', LastUsersAtPosition.as_view(), name='lastuserslocation-detail'),
\end{lstlisting}

O primeiro deles é o que permite que seja realizada a busca de linhas de ônibus pelo número da linha, ao invés do ID interno da mesma. O segundo é o que permite que seja buscada a última localização de um usuário por meio de seu \textit{username}.

E, por fim, temos o \textit{endpoint} que permite que sejam buscados todos os usuários ao redor de uma certa localização em termos de longitude e latitude. Um exemplo de url que se adequa a este \textit{endpoint} é:
``\textit{http://api.trilhasp.datapublika.com/v1/position/last/users/-23.745\_-5.888}''. Neste caso, -23.745 representa a longitude, enquanto -5.888 representa a latitude da localização desejada, e o separador entre latitude e longitude é o símbolo de ``\_'' (\textit{underline}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                  Django                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Projeto Django}
Aqui serão descritas as principais configurações do projeto do \gls{django} e também as produções necessárias para integrar os diversos apps.

\subsubsection{Configurações do Django}
O projeto \gls{django} possui um arquivo de configurações (\textit{settings.py}) que concentra as principais informações do \textit{framework}, incluindo quais \textit{apps}/\textit{plugins}/\textit{módulos} serão utilizados e configurações dos mesmos. A seguir estarão descritas as modificações que foram realizadas com relação ao arquivo padrão do \textit{framework}.

Com relação à configuração de aplicações (\textit{apps}) a serem utilizadas, os seguintes \textit{apps} foram adicionados à lista ``INSTALED\_APPS'':
    \begin{enumerate*}[label=\itshape\alph*\upshape)]
        \item \textit{django.contrib.gis};
        \item \textit{evaluation};
        \item \textit{game};
        \item \textit{demandmap};
        \item \textit{rest\_framework};
        \item \textit{utils}; e
        \item \textit{social.apps.django\_app.default}.
    \end{enumerate*}

Foi também adicionada uma nova variável ao arquivo para configuração do \gls{drf}, chamada ``REST\_FRAMEWORK'', na qual foram definidas a permissão padrão das classes (serializadores e \textit{views}) e também a paginação dos resultados - quantos resultados serão exibidos por página para cada busca realizada na API.

Outra modificação realizada foi na variável ``MIDDLEWARE\_CLASSES'', na qual foram adicionados diversas classes, principalmente as ligadas a autenticação social e ao módulo \textit{django-cors-headers} do \gls{django}.

Adicionou-se uma variável para permitir a comunicação entre endereços \gls{cors} com a diretiva \textit{CORS\_ALLOW\_CREDENTIALS}; foram configurados os \textit{backends} de autenticação do django com a diretiva \textit{AUTHENTICATION\_BACKENDS}; foi adicionado o pipeline\footnote{Sequência de ``comandos'' a serem executados} de autenticação do módulo de autenticação social com a diretiva \textit{SOCIAL\_AUTH\_PIPELINE}, assim como os campos a serem utilizados como referência para se criar a relação entre um ``usuário de rede social'' e um usuário já existente no sistema com a diretiva \textit{SOCIAL\_AUTH\_ADMIN\_USER\_SEARCH\_FIELDS}; foram adicionadas informações de autenticação da aplicação com os servidores de autenticação das redes sociais.

Houve também a configuração de parâmetros de acesso à base de dados na diretiva \textit{DATABASES}, adição da versão do \textit{POSTGIS}, configuração do idioma padrão a ser utilizado, bem como do timezone, e a configuração de endereços de arquivos estáticos (CSS, javascript, imagens, etc) nas diretivas \textit{STATIC\_ROOT} e \textit{STATIC\_URL}, sendo a primeira o endereço absoluto\footnote{Endereço absoluto é o endereço de uma pasta ou arquivo, a partir da raiz do sistema operacional, no próprio equipamento no qual a aplicação está sendo executada.} da pasta de arquivos estáticos e a segunda o complemento da URL no qual os arquivos serão acessados.

\subsubsection{Definição das rotas}
As rotas e endereços do projeto foram definidas tanto no core do projeto quanto no módulo \textit{utils}, conforme exposto na Seção \ref{subsec:util-urls}. Todas as configurações de endereçamento se encontram nos arquivos nominados \textit{urls.py}. No caso deste projeto utilizamos dois arquivos para tais configurações, o primeiro deles é o presente na pasta \textit{trilhasp}, do próprio projeto, e o segundo é o presente no módulo \textit{utils}.

No arquivo presente na pasta \textit{trilhasp} temos as urls para a área de administração, autenticação (\textit{default} e social), além da autenticação padrão da \gls{api} via módulo \gls{rest} e a chamada para as demais urls da API, que se encontram no arquivo do módulo \textit{utils}.

Conforme sugerido na documentação oficial do \gls{drf}, utilizamos a classe \textit{routers} do \textit{framework}, o que facilita a criação dos endpoints, visto que a cada rota registrada no arquivo de configuração, diversas outras rotas são automaticamente criadas pela classe. Apenas como exemplo, ao se definir a rota para a classe empresa de ônibus, são automaticamente criadas as rotas para \textit{listar todas as empresas de ônibus} e \textit{verificar uma única empresa de ônibus}.

Todas as regras de endereçamento contantes na variável \textit{urlpatterns} dos arquivos de configuração de endereços (\textit{urls.py}) podem ser definidas em termos absolutos ou utilizando expressões regulares. Quando uma regra é iniciada por ``\textit{r'....}'' ela será entendida como uma expressão regular, que será comparada com a URL das requisições dos usuários da aplicação.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Nginx & uWSGI                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\textit{Setup} do \textit{backend}}
Nesta seção serão descritas as implantação dos servidores web e de aplicação \gls{nginx} e \gls{uwsgi}, da base de dados Postgres e PostGIS, assim como as devidas configurações e integração com o \textit{framework} \gls{django}.

A pilha de serviços mais utilizada para deploy de aplicações \gls{django}, e que utilizaremos neste projeto, é a apresentada na Figura \ref{fig:djangostack}.
Para esta implementação inicial foi utilizada como referência o tutorial da própria documentação oferecida pela comunidade do \gls{uwsgi}\footnote{``\textit{Setting up Django and your web server with uWSGI and nginx}'' - \url{http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html} - Acesso em 25/09/2014}. Também foi criado um \textit{script} de implantação padronizado para o projeto, baseado na experiência desta instalação.

Vale destacar que os \textit{scripts} e configurações descritos a seguir consideram a implantação em um servidor dedicado - pode ser um \gls{vps}\footnote{\textit{Virtual Private Server} ou Servidor Virtual Privado, é um servidor virtualizado no qual apenas o contratante tem acesso e tem plenos poderes de instalar, desinstalar e configurá-lo como quiser.}; que utiliza como sistema operacional \textit{Debian Jessie (8.0)} e terá um usuário chamado \textit{trilhasp}, em cuja pasta do usuário (\textit{home}) (\textit{/home/trilhasp}) estará a pasta do projeto (\textit{/home/trilhasp/trilhasp}), clonada do repositório git do projeto\footnote{Repositório do projeto \trilhasp: \url{https://github.com/diraol/trilhasp/} - Acesso em 01/12/2014}. Destaca-se ainda que este usuário deve possuir permissão de ``superusuário'' (\textit{sudo}) no sistema operacional. Após realizada a instalação recomenda-se retirar tal permissão do usuário por motivos de segurança do servidor\footnote{``\textit{The Debian Administrator's Handbook}'' - \url{http://debian-handbook.info/browse/stable/} - Acesso em 22/09/2014}.

Tanto os servidores \gls{nginx} e \gls{uwsgi} quanto a base de dados são instalados diretamente no sistema operacional. Já o framework \gls{django} e suas dependências serão instalados por meio de um ``Ambiente Virtual'', ou \textit{virtualenv}. No caso, será utilizada a aplicação Python chamada \textit{virtualenv}\footnote{Python Virtualenv - \url{https://virtualenv.pypa.io/en/latest/} - Acesso em 25/11/2014} para esta instalação.

\clearpage
\diagramaRetrato{django_stack_http.eps}{0.5}{Pilha de serviços do Django}{djangostack}{"\textit{A typical Django HTTP service stack}", por Jeff Buttars em \url{https://code.google.com/p/django-dmq/wiki/Djangocon2011submission\#A\_typical\_Django\_HTTP\_service\_stack} - Acesso em 18/11/2014}{}

Considerando o exposto, e conforme pode ser verificado nos arquivos de instalação do projeto que estão na pasta \textit{setup}, o processo de implantação consiste em instalar os servidores \gls{nginx} e \gls{uwsgi} e o software de base de dados (Postgres) e sua extensão espacial (PostGIS). Em seguida é preciso configurá-los todos, utilizando os arquivos distribuídos junto do projeto (\textit{trilhasp\_nginx.conf}, \textit{trilhasp\_uwsgi.ini} e \textit{uwsgi\_params}), criar o usuário na base de dados, o \textit{schema} ou \textit{database}, e instalar neste a extensão geo do PostGIS.

O passo seguinte é criar o ambiente virtual, instalar nele o \gls{django} e as dependências python do projeto, configuradas no arquivo \textit{requirements.py}, criar o arquivo de configuração (\textit{settings.py}) do \gls{django} baseado nos \textit{templates} disponibilizados que se encontram na pasta ``\textit{trilhasp/trilhasp/}'' e, por fim, referenciar o projeto \gls{django} corretamente no \gls{uwsgi} e vincular o \gls{uwsgi} ao \gls{nginx}.

Outro passo fundamental é a correta configuração \gls{cors}. No servidor web \gls{nginx} esta configuração é realizada alterando-se os cabeçalhos da requisição, em especial os parâmetros ``\textit{Access-Control-Allow-Origin}'', ``\textit{Access-Control-Allow-Credentials}'', ``\textit{Access-Control-Allow-Methods}'' e ``\textit{Access-Control-Allow-Headers}'' no arquivo ``\textit{trilhasp\_nginx.conf}''. No projeto \gls{django} a configuração é realizada no arquivo ``\textit{settings.py}''. E também é necessário realizar algumas configurações no próprio aplicativo móvel, que serão descritas na Seção \ref{sec:spec-appmobile} deste trabalho.

\section{Aplicativo Mobile}\label{sec:spec-appmobile}
Conforme exposto anteriormente, optou-se por utilizar um modelo de desenvolvimento móvel híbrido. Para tanto, escolheu-se o \textit{framework} \gls{ionic}, que integra-se à plataforma \gls{cordova}, que encapsula a aplicação desenvolvida com o \gls{ionic} e simula uma aplicação nativa do celular. É extremamente comum, também, utilizar junto ao \gls{ionic} outro framework, o \gls{angular}, para automatizar ainda mais o processo de desenvolvimento, e essa foi uma escolha que foi seguida pela projeto.

\subsection{\textit{Framework} Cordova}
De acordo com as estatísticas do portal AppBrain%
\footnote{AppBrain Stats - Android \textit{app frameworks} - \url{http://www.appbrain.com/stats/libraries/tag/app-framework/android-app-frameworks} - Acesso em 17/08/2014},
o \textit{Framework} Cordova%
\footnote{Apache Cordova - \url{http://cordova.apache.org/} - Acesso em 17/08/2014},
e sua versão proprietária PhoneGap, é o terceiro framework de desenvolvimento de aplicativos Android mais utilizado no mercado, em termos de instalações realizadas, e o primeiro em termos de aplicativos desenvolvidos.

Na figura \ref{fig:cordova-build-stack} podemos ver como funciona, de forma geral, a abordagem híbrida. O primeiro passo é construir um projeto Web, utilizando \gls{html}, CSS e JavaScript. Em geral recomenda-se utilizar algum \textit{framework} de Interface de Usuário (\textit{UI Framework}) para desenvolvimento Web com foco em dispositivos móveis, como por exemplo jQuery Mobile%
\footnote{jQuery Mobile - \url{http://jquerymobile.com/} - Acesso em 21/08/2014}
ou Dojo Mobile%
\footnote{Dojo Mobile - \url{http://dojotoolkit.org/features/mobile} - Acesso em 21/08/2014}.

Caso se deseje utilizar recursos nativos do dispositivo móvel, como câmera ou gps, deve-se adicionar também os devidos plugins do \textit{framework} Cordova que fornecerão acesso à API do dispositivo após o empacotamento do projeto. O passo seguinte é executar o empacotamento do projeto para a plataforma que se deseja (Android, iOS, Palm, etc) utilizando o Cordova e, por fim, realizar a instalação do aplicativo gerado no dispositivo.

Em termos de plugins para acesso à API nativa dos dispositivos móveis, foram necessárias as instalações dos seguintes:
\begin{description}
    \item[Keyboard] - com.ionic.keyboard 1.0.3;
    \item[Camera] - org.apache.cordova.camera 0.3.3;
    \item[Device] - org.apache.cordova.device 0.2.12;
    \item[BarcodeScanner] - https://github.com/wildabeast/BarcodeScanner.git;
    \item[BackgroundMode] - de.appplant.cordova.plugin.background-mode 0.6.0-dev;
    \item[Console] - org.apache.cordova.console 0.2.11; e
    \item[Geolocation] - org.apache.cordova.geolocation 0.3.10.
\end{description}

\diagramaRetrato{cordova-build.png}{0.55}{Etapas da produção híbrida}{cordova-build-stack}{Autoria Própria, baseada em ``PhoneGap Build Structure'' - \url{http://www.thedevline.com/2014/03/beginning-apps-development-you-must.html} - Acesso em 21/08/2014}{}    

O processo de instalação e configuração do ambiente de desenvolvimento do aplicativo está descrito no arquivo ``README.me'' no repositório do projeto\footnote{Repositório do Aplicativo Móvel \trilhasp: \url{https://github.com/diraol/trilhasp-mobile}}.

\subsection{Estrutura do projeto do Aplicativo Móvel}
O desenvolvimento do aplicativo móvel se dá, fundamentalmente, no projeto web do mesmo, ou seja, na pasta ``\textit{www}'' do projeto que se encontra no repositório. Na pasta ``\textit{www/css}'' encontramos os arquivos de folha de estilo do projeto, que definem as características visuais do mesmo, sendo que o único arquivo utilizado para personalização visual do projeto é o ``\textit{style.css}'', enquanto os demais são arquivos padrão das tecnologias utilizadas.

O código \gls{html} serve para definir a estrutura de conteúdo das páginas, ou ``telas''. Os \textit{frameworks} escolhidos para desenvolver esta parte do projeto, \textit{ionic} e \gls{angular}, permitem que se definam algumas heranças entre os arquivos \gls{html}. Assim, o arquivo \textit{index.html} possui toda estrutura básica do projeto, e ele será ``extendido'' pelos demais arquivos. Esta possibilidade permite que existam algumas características comuns entre as páginas e que no código fonte estas características estejam apenas em um lugar, não em diversos, o que melhora a manutenabilidade do projeto. Os demais arquivos \gls{html} se encontram dentro da pasta ``\textit{www/templates}'', e cada um representará um recurso do aplicativo.

\subsubsection{Lógica de Negócio do aplicativo}
A lógica de negócio que ocorre no próprio aplicativo (\textit{client-side}) é realizada pelos códigos JavaScript que se encontram na pasta ``\textit{www/js}''. Nela encontramos 3 arquivos:
\begin{enumerate*}[label=\itshape\alph*\upshape)]
    \item \textit{app.js};
    \item \textit{controllers.js}; e
    \item \textit{services.js}.
\end{enumerate*}

O principal deles, \textit{app.js}, é o que contém as principais variáveis de ambiente, a instanciação dos módulos - sejam eles módulos dos \textit{frameworks} utilizados, ou módulos que serão desenvolvidos; as regras de roteamento de estados%
\footnote{No desenvolvimento híbrido cada tela do aplicativo final pode ser considerada como uma página do desenvolvimento web tradicional, assim, cada tela terá seu próprio endereço web, mas que é acessado localmente dentro do aplicativo. Este processo não é visível para os usuários da aplicação. O \gls{angular} trabalha com o conceito de \textit{Estados}, então toda troca de ``endereço'' corresponde a uma troca de ``estado''.},
regras de controle de contexto e a chamada para execução do aplicativo em si.

No arquivo \textit{controllers.js} encontram-se os controladores que serão chamados pelas regras de roteamento e irão executar as funções específicas de cada estado.

Por fim, no arquivo \textit{services.js} encontram-se alguns \textit{serviços} que foram criados, que podem ser entendidos com funções que são chamadas em determinadas condições. Aqui destacam-se dois até o momento:
\begin{description}
    \item[authInterceptor] - função que verifica, a cada mudança de estado, se o usuário está efetivamente logado no sistema e autenticado no \textit{backend} e retorna para a tela de login caso não esteja; e
    \item[QRScanService] - serviço que realiza a leitura do código de barras e decodifica o mesmo, retornando seu valor para a função que o chamou.
\end{description}

Uma das características fundamentais do framework \gls{angular} são as ``promessas'' (\textit{promises})\footnote{``AngularJS Promises - O guia definitivo'' - \url{http://nomadev.com.br/angularjs-promises-promessas-o-guia-definitivo/} - Acessado em 25/08/2014}, que podem ser entendidas como operações assíncronas que devolverão algum resultado num instante futuro. Como o processamento se dá de forma assíncrona, o trecho de código que a chamou não esperará pelo resultado para prosseguir. Isso significa que o serviço (ou função) é chamado, o trecho de código continua a ser executado, e quando a promessa retorna um resultado (ou erro), ela executará a função de \textit{callback} que foi passada a ela. O Serviço \textit{QRScanService} atua desta maneira, assim como requisições \gls{http} realizadas no javascript.

\subsection{Estados do Aplicativo}
Até o momento, o aplicativo conta com oito estados. Na Tabela \ref{tab:app-estados} são listados os estados, e os respectivos endereços, templates e controladores associados a eles.

\begin{table}[htb]
  \IBGEtab{%
    \renewcommand{\arraystretch}{1.3}    
    \caption{Estados do Aplicativo Móvel\label{tab:app-estados}}    
  }{
    \begin{tabular}{|P{3.4cm}|P{3.2cm}|P{4cm}|P{2.8cm}|}
    \hline
        \textbf{Estado} & \textbf{URL} & \textbf{Template} & \textbf{Controlador} \\
    \hline \hline
        login & /login & login.html & UserCtrl\\ \hline
        app & /app & menu.html & AppCtrl\\ \hline
        app.home & /home & main.html & HomeCtrl\\ \hline
        app.avaliacao & /avaliacao & avaliacao.html & AvCtrl\\ \hline
        app.avaliacaogeral & /avaliacao/geral/ & avaliacao\_geral.html & AvGeralCtrl\\ \hline
        app.avaliacaoespecifica & /avaliacao/especifica/ & avaliaca\_especifica.html& AvEspecificaCtrl\\ \hline
        app.map & /map & map.html & MapCtrl\\ \hline
        app.game & /game & game.html & GameCtrl\\
    \hline
    \end{tabular}%
  }{%
    \fonte{Autoria Própria}
    \nota{Os templates se encontram dentro da pasta \textit{/www/templates}.}
  }
\end{table}

\subsubsection{Login}
Este é o estado de \textit{fallback} padrão para o caso de o usuário não estar autenticado. Os botões para autenticação via rede social ainda não estão disponíveis pois ainda não foram implementadas regras de segurança nos ambientes, como por exemplo a utilização de certificados de segurança e protocolo \gls{https}%
\footnote{``HTTPS (Hyper Text Transfer Protocol Secure - protocolo de transferência de hipertexto seguro) é uma implementação do protocolo HTTP sobre uma camada adicional de segurança que utiliza o protocolo SSL/TLS. Essa camada adicional permite que os dados sejam transmitidos por meio de uma conexão criptografada e que se verifique a autenticidade do servidor e do cliente por meio de certificados digitais. A porta TCP usada por norma para o protocolo HTTPS é a 443.'' - \url{http://pt.wikipedia.org/wiki/HTTPS} - Acesso em 23/10/2014},
fazendo com que as informações transitadas entre o aplicativo e o servidor fiquem expostas a ataques.

Este estado se comunica com a \gls{api} por meio do \textit{endpoint} ``\textit{/o/token/}''. Para que esta requisição de autenticação possa acontecer, é necessário passar um parâmetro no cabeçalho (\textit{header}) \gls{http} da requisição chamado ``\textit{Authorization}''. O conteúdo deste é composto pelo texto ``Basic\textvisiblespace'' seguido da string que codifica em base64 o \textit{client\_id} e \textit{client\_secret} da aplicação separados pelo símbolo de dois pontos. O \textit{client\_id} e o \textit{client\_secret} devem ser obtidos no \textit{endpoint} \textit{/o/applications/}\footnote{\textit{Django OAuth Toolkit} - \url{https://github.com/evonove/django-oauth-toolkit/blob/master/docs/rest-framework/getting\_started.rst} - Acesso em 18/11/2014}.

Caso a autenticação ocorra com sucesso, no corpo da resposta \gls{http} virá um parâmetro chamado ``\textit{access\_token}''. Este irá compor o novo código de Autorização (\textit{Authorization}) do cabeçalho de todas as requisições daqui em diante. Porém, ao invés de ele ser composto com a string ``Basic'' ele será composto com a string ``Bearer\textvisiblespace''.

\subsubsection{App}
Este estado, que serve de base para os demais estados iniciados por \textit{app}, é responsável por salvar a posição do usuário periodicamente, possui a função de \textit{logoff} e também adiciona um menu no aplicativo. Tanto o menu quanto as funções estão disponíveis em todos os estados, exceto o de login.

Como este estado é responsável por armazenar a localização do usuário, ele se comunica com os \textit{endpoints} ``/v1/position/last/'' e ``/v1/position/history''.

\subsubsection{App.home}
Este é o estado inicial apresentado ao usuário após o login. Nele são mostrados os módulos disponíveis para o usuário em forma de lista.

\subsubsection{App.avaliacao}
Este é o primeiro estado do processo de avaliação do ônibus. Nele o usuário irá identificar, por meio do \gls{qrcode} a identificação do veículo que ele irá avaliar. Caso o código identificado não esteja cadastrado no \textit{backend} ou esteja inativo, o usuário irá receber uma mensagem informando que o código é inválido e a ele será dada a opção de tentar novamente.

Para escanear o \gls{qrcode}, o usuário deverá pressionar um botão na tela e ``encaixar'' o \gls{qrcode} na área mais clara da tela. Caso haja uma correta identificação o usuário será automaticamente direcionado para o estado seguinte, descrito na Seção \ref{subsubsec:app-aval-geral}.

Esta leitura é será realizada no próprio celular do usuário por meio de um plugin/módulo do \textit{framework} Cordova chamado ``\textit{BarcodeScanner}''\footnote{\textit{BarcodeScanner} - \url{https://github.com/wildabeast/BarcodeScanner} - Acesso em 16/11/2014}.

Este estado se comunica com a \gls{api} por meio do endpoint ``/v1/evaluation/bus/'', para verificar se o ônibus existe na base de dados e se o mesmo está ativo.

\subsubsection{App.avaliacaogeral}\label{subsubsec:app-aval-geral}
Neste estado é realizada a Avaliação Geral do serviço. Nela é apresentado o número do veículo e a linha associada a ele, além de um \textit{slider} no qual o usuário escolherá a nota, conforme pode ser visto na Figura \ref{fig:print-avgeral}.

\diagramaRetrato{av-geral.png}{0.6}{Tela de Avaliação Geral}{print-avgeral}{Autoria Própria}{}

À esquerda do slider foi colocado um símbolo indicando reprovação, e à direita um símbolo indicando aprovação. Ao se tocar nestes símbolos a avaliação é automaticamente colocada no valor mínimo ou máximo, respectivamente.

Há ainda a possibilidade de se utilizar uma escala adicional de cores para intensificar a noção de avaliação positiva e negativa, assim como pode-se utilizar figuras de rostos alegres e tristes.

O controlador deste estado verifica, por meio da diretiva ``\textit{ng-change}'' do \gls{angular} as mudanças no \textit{slider} e, caso o valor seja menor que a metade do mesmo, ele irá mostrar a caixa de texto para que o usuário possa inserir um comentário sobre a avaliação.

Neste estado o usuário pode optar por prosseguir para as avaliações específicas ou pode finalizar a avaliação apenas com a avaliação geral.

Este estado se comunica com a \gls{api} por meio do \textit{endpoint} ``/v1/evaluation/answer/'' para salvar a resposta do usuário.

\subsubsection{Avaliações Específicas}
Este estado, que só pode ser atingido após o estado App.avaliacaogeral, é o estado no qual se realizam as avaliações específicas.

Por meio da diretiva ``\textit{ng-repeat}'' do \gls{angular}, o controlador \textit{AvEspecificaCtrl} consulta o \textit{backend}, recupera as perguntas que estão ativas no momento e preenche automaticamente, na tela, as perguntas que serão apresentadas ao usuário, uma por aba.

O comportamento de cada pergunta é semelhante ao comportamento descrito na Seção \ref{subsubsec:app-aval-geral}, e ao usuário é apresentado um botão ``Finalizar'' para encerrar a avaliação.

Este estado se comunica com a \gls{api} por meio do \textit{endpoint} ``/v1/evaluation/question/?format=jsonp\&callback=JSON\_CALLBACK'' para recuperar quais são as avaliações específicas cadastradas e ativas no sistema que serão apresentadas ao usuário, e por meio do \textit{endpoint} ``/v1/evaluation/answer/'' para salvar as respostas no final do processo de avaliação.

\subsubsection{App.map}
Este estado representa o módulo \textbf{GPS Social}, e nele é apresentado ao usuário o mapa com todos os usuários conectados no momento.

O mapa é gerado utilizando a biblioteca leaflet.js\footnote{Leaflet.js - \url{http://leafletjs.com/} - Acesso em 20/11/2014}, uma biblioteca javascript livre para produção de mapas, e os \textit{tiles} disponibilizados pelo projeto OpenStreetMap\footnote{OpenStreetMaps - \url{http://www.openstreetmap.org/about} - Acesso em 20/11/2014}, que fornece o serviço gratuitamente e é construído por um esforço coletivo de milhares de pessoas.

O mapa é populado com os usuários ativos, por meio da consulta à \gls{api} no \textit{endpoint} ``position/last/?format=jsonp\&callback=JSON\_CALLBACK''.

Também foi utilizado o recurso de agrupamento (\textit{clustering}) da biblioteca\footnote{Leaflet Markercluster - \url{https://github.com/Leaflet/Leaflet.markercluster} - Acesso em 27/11/2014}, que faz com que os marcadores (\textit{markers}) que representam usuários sejam agrupados num único marcador que contém o número de marcadores agrupados naquele ponto. Dessa maneira o usuário pode ver numericamente a quantidade de usuários presentes em cada ponto. O agrupamento ocorre por proximidade e depende do zoom que está sendo utilizado. Além disso, também é possível configurar o estilo dos marcadores, de maneira que os marcadores de agrupamento possuam também, além do número, uma tonalidade que represente uma faixa de valores proporcional à quantidade de usuários agrupados.

No controlador deste estado (\textit{MapCtrl}) também há uma configuração para que os pontos sejam atualizados periodicamente. Este parâmetro, por hora, está \textit{hardcoded} no código fonte, mas pode-se alterá-lo para que ele seja consultado na base de dados, de forma que ele possa ser alterado sem a necessidade de mudanças no código fonte do aplicativo.

\diagramaRetrato{leaflet-cluster.png}{0.8}{Mapa com LeafletJS e Agrupamento de marcadores}{print-gps-social}{A. Santiago - \url{http://acuriousanimal.com/blog/2012/08/12/awesome-clustered-markers-in-leaflet/} - Acesso em 10/12/2014}{}

\subsubsection{App.game}
A implementação do game no aplicativo móvel não foi realizada por falta de tempo para tal. Caso o usuário tente acessar o módulo de game do aplicativo a ele será apresentada uma mensagem de que o jogo ainda não está disponível.

Entretanto, a seguir serão apresentados os principais estados que comporiam o game de acordo com planejamento inicial.
\begin{description}
    \item[App.gamecomprar] - Neste estado serão apresentados ao usuário os ônibus que ele pode comprar para montar sua frota, assim como seu saldo financeiro. Ele poderá optar pelo veículo que deseja adquirir, a quantidade e confirmar a compra. Em seguida ele será direcionado ao estado que permite compartilhar a compra realizada;
    \item[App.gameshare] - Neste estado o usuário será convidado a compartilhar em suas redes sociais a compra que acabou de realizar; e
    \item[App.gameprofile] - Neste estado será apresentada ao usuário sua frota atual, quantos ônibus ele possui, de quais modelos, e quanto tempo falta para eles ``renderem'' e retornarem financeiramente ao usuário.
\end{description}

\subsection{Background}
É fundamental ainda que o aplicativo móvel possa ser executado em \textit{background} no celular do usuário, para poder manter a informação de geolocalização atualizada e, no futuro, poder enviar notificações ao mesmo.

Este recurso foi adicionado ao aplicativo utilizando o plugin do \textit{framework} Cordova chamado ``\textit{Cordova Background Plug-in}''\footnote{Cordova Background Plug-in - \url{https://github.com/katzer/cordova-plugin-background-mode} - Acesso em: 13/12/2014}.

\subsection{Compilando o aplicativo mobile}
Para compilar o aplicativo e gerar uma versão instalável, basta entrar no diretório do projeto, utilizando o terminal de linha de comando, e executar o comando: 
\begin{lstlisting}[language=Python,caption={Sintaxe padrão para registro de endereço no \textit{router}}]
cordova build android
\end{lstlisting}

O comando anterior resultará num pacote ``\textit{.apk}'' que poderá ser instalado num celular \gls{android}. Para compilá-lo para dispositivos com sistema operacional iOS é necessário rodar o projeto a partir de um sistema operacional OSx, da Apple. Neste caso bastaria trocar o termo ``android'' do comando por ``ios''.

Outra opção é apenas executar o aplicativo num emulador, utilizando o comando:
\begin{lstlisting}[language=Python,caption={Sintaxe padrão para registro de endereço no \textit{router}}]
cordova run android
\end{lstlisting}

\include{./texto/especificacoes/avaliacoes}
\include{./texto/especificacoes/requisitos-funcionais}
\input{./texto/especificacoes/requisitos-nao-funcionais}